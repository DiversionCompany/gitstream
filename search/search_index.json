{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"/:\\ gitStream gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity. Build Your First Automation in 2 Minutes GitHub GitLab BitBucket Install gitStream for free in GitHub Configure your repository using the instructions for GitHub . This will guide you through setting up your first automations. That's it! Now sit back and watch gitStream run automation rules on your next PR. Tip: Install gitStream for your entire organizaton gitStream can be installed for one repo, specific repos, or all repos in your organization. We recommend installing for all because it will ensure all new repos are able to use gitStream. You can change this setting at any time in the future. Follow the installation instructions for GitLab here Coming soon Features Auto-Merge PRs Not all PRs need extensive review policies that loop in multiple experts. gitStream lets you auto-merge safe changes , small fixes , PRs from trusted teams , and anything else you want to unblock the review process to keep your team focused on their work. Contextual Labels Reduce the mental burden of code reviews with labels that provide a high degree of context. Indicate an estimated time to review or flag potential issues with Jira information , missing tests , deleted files , and more. Review Assignment Identifying the correct people to review a PR can take time, particularly for complex projects and repos requiring deep expertise. Assign code experts to review complex PRs, notify your security team about sensitive changes , and automatically assign reviewers based on the contents of the PR . Automated Change Requests Reduce code review noise by catching issues before anyone invests precious time. Flag deprecated components , missing data objects , off-limits code , and other problems that need to be addressed before assigning code reviewers. Install /:\\ gitStream Now GitHub GitLab Get Involved Want to report a bug, request a new feature, ask a question, get updates for new features, or propose a new configuration for the automation library? Join us on GitHub .","title":"Overview"},{"location":"#gitstream","text":"gitStream is a workflow automation tool that enables you to use YAML configuration files to optimize your code review process. Add context to PRs, find code experts for reviews, and automate the merge process to maximize developer productivity. Build Your First Automation in 2 Minutes GitHub GitLab BitBucket Install gitStream for free in GitHub Configure your repository using the instructions for GitHub . This will guide you through setting up your first automations. That's it! Now sit back and watch gitStream run automation rules on your next PR. Tip: Install gitStream for your entire organizaton gitStream can be installed for one repo, specific repos, or all repos in your organization. We recommend installing for all because it will ensure all new repos are able to use gitStream. You can change this setting at any time in the future. Follow the installation instructions for GitLab here Coming soon","title":"/:\\ gitStream"},{"location":"#features","text":"Auto-Merge PRs Not all PRs need extensive review policies that loop in multiple experts. gitStream lets you auto-merge safe changes , small fixes , PRs from trusted teams , and anything else you want to unblock the review process to keep your team focused on their work. Contextual Labels Reduce the mental burden of code reviews with labels that provide a high degree of context. Indicate an estimated time to review or flag potential issues with Jira information , missing tests , deleted files , and more. Review Assignment Identifying the correct people to review a PR can take time, particularly for complex projects and repos requiring deep expertise. Assign code experts to review complex PRs, notify your security team about sensitive changes , and automatically assign reviewers based on the contents of the PR . Automated Change Requests Reduce code review noise by catching issues before anyone invests precious time. Flag deprecated components , missing data objects , off-limits code , and other problems that need to be addressed before assigning code reviewers. Install /:\\ gitStream Now GitHub GitLab","title":"Features"},{"location":"#get-involved","text":"Want to report a bug, request a new feature, ask a question, get updates for new features, or propose a new configuration for the automation library? Join us on GitHub .","title":"Get Involved"},{"location":"automation-actions/","text":"Automation actions Actions are the end results of the automation described in your .cm file. Note The icons for Git providers indicate the actions supported by each provider. GitHub GitLab Overview gitStream executes actions in the order they are listed. If an action result fails, following actions will not be executed. add-comment add-label add-labels add-reviewers approve close merge set-required-approvals require-reviewers request-changes Note Multiple actions can be listed in a single automation. The actions are invoked one by one. Dynamic actions arguments Arguments values a dynamic value is supported using expressions based on Jinja2 syntax, and includes gitStream context variables, for example: automations : pr_complexity : if : - true run : - action : add-comment@v1 args : comment : \"Estimated {{ branch | estimatedReviewTime }} minutes to review\" Reference add-comment This action, once triggered, adds a comment to the PR. This is a manged action, when a PR updates, the existing comments that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description comment Required String Sets the comment, markdown is supported example automations : senior_review : if : - {{ files | match ( term = 'core/' ) | some }} run : - action : add-comment@v1 args : comment : | Core service update (Updates API) add-label This action, once triggered, adds a label to the PR. This is a manged action, when a PR updates, the existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description label Required String The label text any string can work color Optional String The color in hex, for example: 'FEFEFE' (you can also add # prefix #FEFEFE ) example automations : senior_review : if : - {{ files | match ( term = 'api/' ) | some }} run : - action : add-label@v1 args : label : api-change add-labels This action, once triggered, adds a list of labels to the PR. This is a manged action, when a PR updates existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description labels Required [String] The list of text labels add-reviewers This action, once triggered, sets a specific reviewer. Args Usage Type Description reviewers Required [String] Sets required reviewers. Supports user names and teams. Teams notated by adding a prefix with the owner name e.g. owner/team team_reviewers Optional [String] Sets required team reviewers without a prefix team unless_reviewers_set Optional Bool When true , the reviewers are not added if the PR has already assigned reviewers. It is set to false by default fail_on_error Optional Bool When true , trying to assign illegal reviewers shall fail the automation, when false these errors are silently ignored. It is set to true by default example automations : senior_review : if : - {{ files | match ( term = 'src/ui/' ) }} run : - action : add-reviewers@v1 args : reviewers : [ popeye , olive , acme/team-a ] Enable Team Write Access If you want to assign teams as PR reviewers, you need to first make sure the team has write access to the repo in via your organization's settings. For more info, refer to the GitHub instructions for managing team review settings . approve This action, once triggered, approves the PR for merge. This is a manged action, when a PR updates existing approval by gitStream is re-evaluated and removed if no longer applicable. example automations : small_change : if : - {{ source.diff.files | isFormattingChange }} run : - action : approve@v1 close This action, once triggered, close the PR without merging. example automations : close_ui_changes_by_non_ui : if : - {{ files | match ( regex = r / src \\ / views /) | some }} - {{ pr.author_teams | match ( term = 'ui-team' ) | nope }} run : - action : add-comment@v1 args : comment : | Please contact a member of `ui-team` team if you need to make changes to files in `src/views` - action : close@v1 merge Once triggered, merge the PR if possible. It can set to wait for required checks to pass or ignore checks. Args Usage Type Description wait_for_all_checks Optional Boolean By default false , so only Required checks can block merge, when true the action won't merge even if non-Required check fail rebase_on_merge Optional Boolean By default false , when merging use rebase mode squash_on_merge Optional Boolean By default false , when merging use squash mode example automations : small_change : if : - {{ files | allDocs }} run : - action : merge@v1 args : rebase_on_merge : true set-required-approvals This action, once triggered, blocks PR merge till the desired reviewers approved the PR. The actions fail the check to prevent the PR for merge. Args Usage Type Description approvals Required Integer Sets the number of required reviewer approvals for merge for that PR example automations : double_review : if : - {{ files | match ( regex = r / agent \\ //) | some }} run : - action : set-required-approvals@v1 args : approvals : 2 Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub. request-changes This action, once triggered, request changes on the PR. As long as request change is set, gitStream will block the PR merge. This is a manged action, when a PR updates existing change request by gitStream is re-evaluated and removed if no longer applicable. Args Usage Type Description comment Required [String] The desired request changes comment example automations : catch_deprecated : if : - {{ source.diff.files | matchDiffLines ( regex = r / ^ [+] . * oldFetch \\ (/ ' ) | some }} run : - action : request-changes@v1 args : comment : | You have used deprecated API `oldFetch`, use `newFetch` instead. Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub. require-reviewers This action, once triggered, requires a specific reviewer approval. The PR merge is blocked till approved by either of the listed users or teams. Args Usage Type Description reviewers Required [String] Sets required reviewers. Supports user names and teams. Teams notated by adding a prefix with the owner name e.g. owner/team . Merge is blocked till approved by either of the listed users also_assign Optional Bool true by default, also assign the specified users as reviewers example automations : senior_review : if : - {{ files | match ( regex = r / src \\ / ui \\ //) | some }} run : - action : require-reviewers@v1 args : reviewers : [ popeye , olive , acme/team-a ] Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.","title":"Automation actions"},{"location":"automation-actions/#automation-actions","text":"Actions are the end results of the automation described in your .cm file. Note The icons for Git providers indicate the actions supported by each provider. GitHub GitLab","title":"Automation actions"},{"location":"automation-actions/#overview","text":"gitStream executes actions in the order they are listed. If an action result fails, following actions will not be executed. add-comment add-label add-labels add-reviewers approve close merge set-required-approvals require-reviewers request-changes Note Multiple actions can be listed in a single automation. The actions are invoked one by one.","title":"Overview"},{"location":"automation-actions/#dynamic-actions-arguments","text":"Arguments values a dynamic value is supported using expressions based on Jinja2 syntax, and includes gitStream context variables, for example: automations : pr_complexity : if : - true run : - action : add-comment@v1 args : comment : \"Estimated {{ branch | estimatedReviewTime }} minutes to review\"","title":"Dynamic actions arguments"},{"location":"automation-actions/#reference","text":"","title":"Reference"},{"location":"automation-actions/#add-comment","text":"This action, once triggered, adds a comment to the PR. This is a manged action, when a PR updates, the existing comments that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description comment Required String Sets the comment, markdown is supported example automations : senior_review : if : - {{ files | match ( term = 'core/' ) | some }} run : - action : add-comment@v1 args : comment : | Core service update (Updates API)","title":"add-comment  "},{"location":"automation-actions/#add-label","text":"This action, once triggered, adds a label to the PR. This is a manged action, when a PR updates, the existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description label Required String The label text any string can work color Optional String The color in hex, for example: 'FEFEFE' (you can also add # prefix #FEFEFE ) example automations : senior_review : if : - {{ files | match ( term = 'api/' ) | some }} run : - action : add-label@v1 args : label : api-change","title":"add-label  "},{"location":"automation-actions/#add-labels","text":"This action, once triggered, adds a list of labels to the PR. This is a manged action, when a PR updates existing labels that were added by gitStream are re-evaluated and those that are not applicable are removed. Args Usage Type Description labels Required [String] The list of text labels","title":"add-labels  "},{"location":"automation-actions/#add-reviewers","text":"This action, once triggered, sets a specific reviewer. Args Usage Type Description reviewers Required [String] Sets required reviewers. Supports user names and teams. Teams notated by adding a prefix with the owner name e.g. owner/team team_reviewers Optional [String] Sets required team reviewers without a prefix team unless_reviewers_set Optional Bool When true , the reviewers are not added if the PR has already assigned reviewers. It is set to false by default fail_on_error Optional Bool When true , trying to assign illegal reviewers shall fail the automation, when false these errors are silently ignored. It is set to true by default example automations : senior_review : if : - {{ files | match ( term = 'src/ui/' ) }} run : - action : add-reviewers@v1 args : reviewers : [ popeye , olive , acme/team-a ] Enable Team Write Access If you want to assign teams as PR reviewers, you need to first make sure the team has write access to the repo in via your organization's settings. For more info, refer to the GitHub instructions for managing team review settings .","title":"add-reviewers  "},{"location":"automation-actions/#approve","text":"This action, once triggered, approves the PR for merge. This is a manged action, when a PR updates existing approval by gitStream is re-evaluated and removed if no longer applicable. example automations : small_change : if : - {{ source.diff.files | isFormattingChange }} run : - action : approve@v1","title":"approve  "},{"location":"automation-actions/#close","text":"This action, once triggered, close the PR without merging. example automations : close_ui_changes_by_non_ui : if : - {{ files | match ( regex = r / src \\ / views /) | some }} - {{ pr.author_teams | match ( term = 'ui-team' ) | nope }} run : - action : add-comment@v1 args : comment : | Please contact a member of `ui-team` team if you need to make changes to files in `src/views` - action : close@v1","title":"close  "},{"location":"automation-actions/#merge","text":"Once triggered, merge the PR if possible. It can set to wait for required checks to pass or ignore checks. Args Usage Type Description wait_for_all_checks Optional Boolean By default false , so only Required checks can block merge, when true the action won't merge even if non-Required check fail rebase_on_merge Optional Boolean By default false , when merging use rebase mode squash_on_merge Optional Boolean By default false , when merging use squash mode example automations : small_change : if : - {{ files | allDocs }} run : - action : merge@v1 args : rebase_on_merge : true","title":"merge  "},{"location":"automation-actions/#set-required-approvals","text":"This action, once triggered, blocks PR merge till the desired reviewers approved the PR. The actions fail the check to prevent the PR for merge. Args Usage Type Description approvals Required Integer Sets the number of required reviewer approvals for merge for that PR example automations : double_review : if : - {{ files | match ( regex = r / agent \\ //) | some }} run : - action : set-required-approvals@v1 args : approvals : 2 Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.","title":"set-required-approvals "},{"location":"automation-actions/#request-changes","text":"This action, once triggered, request changes on the PR. As long as request change is set, gitStream will block the PR merge. This is a manged action, when a PR updates existing change request by gitStream is re-evaluated and removed if no longer applicable. Args Usage Type Description comment Required [String] The desired request changes comment example automations : catch_deprecated : if : - {{ source.diff.files | matchDiffLines ( regex = r / ^ [+] . * oldFetch \\ (/ ' ) | some }} run : - action : request-changes@v1 args : comment : | You have used deprecated API `oldFetch`, use `newFetch` instead. Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.","title":"request-changes "},{"location":"automation-actions/#require-reviewers","text":"This action, once triggered, requires a specific reviewer approval. The PR merge is blocked till approved by either of the listed users or teams. Args Usage Type Description reviewers Required [String] Sets required reviewers. Supports user names and teams. Teams notated by adding a prefix with the owner name e.g. owner/team . Merge is blocked till approved by either of the listed users also_assign Optional Bool true by default, also assign the specified users as reviewers example automations : senior_review : if : - {{ files | match ( regex = r / src \\ / ui \\ //) | some }} run : - action : require-reviewers@v1 args : reviewers : [ popeye , olive , acme/team-a ] Attention To allow this action to block merge, you should enable branch protection, and gitStream has to be set as required check in GitHub.","title":"require-reviewers "},{"location":"cm-file/","text":"Overview Continuous Merge automation files have a .cm extension. In a repository, gitStream loads and parse the .cm directory, which can have multiple automation files, each of which is evaluated independently. You can edit the .cm files and add your own checks and rules. Check out the Automation examples . Automation rules There are two types of automation rules: repository level rules and organization level rules. Repository level rules are set by creating a special .cm directory in the repository root. Automation rules are specified in files in this directory, which can have any name but must end with .cm . Organization level rules are defined by creating a special repository named cm in the organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected. When organization level rules are defines, repository level automation shall take precedence and override organization automation when having the same identifier. An automation identifier is a composition of the CM file name and the automation name. For example when safe_changes is defined in gitstream.cm then the automation identifier shall be gitstream/safe_changes Tip You can exclude certain repositories per automation file using the config.ignore_repositories Repository automation rules Repository automation rules are set by creating a special .cm directory in your repository root. Automation rules are specified in files in this directory, these files can have any name but must end with .cm . By default, you start with a single automation file .cm/gitstream.cm . Every file is parsed independently, and the parsing results are combined and executed. Specifically: Automation rules are allowed to have same name in different .cm files The config section is defined per .cm file (except config.admin ) Any accessory expression defined in each file scope, therefore cannot be reused in another file (but it can be duplicated) When configured correctly, your repository directory structure should look like that (for GitHub): Repsository automation rules . \u251c\u2500 .cm/ \u2502 \u2514\u2500 *.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml Note The .cm/gitstream.cm is special, as it allows for repository level configuration such as config.admin . Organization automation rules Organization automation rules are defined by creating a special repository cm in your organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected. When configured correctly, the cm repository directory structure should look like that (for GitHub): Repsository automation rules . \u251c\u2500 *.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml For each PR the following automation rules are applied: Repository level rules Organization level rules, unless with the same identifier as a repository level automation When organization level rules are defined, then the CI/CD will be executed on the cm repository on behalf of the PR repository. Setting up Global Automation rules By utilizing the following techniques, you can effectively combine and manage global and repository rules to customize the behavior of your automations to fit the specific requirements of your repositories: Global rules are defined in the configuration management cm repository and are applied to all repositories that are connected to gitStream. To exclude a specific repository from a global rule, you can create a configuration file in the cm repository and add a list of the unwanted repositories under the config.ignore_repositories property in the CM file. To override a global rule for a specific automation in a repository, you can duplicate the rule (both the file and automation name) and place it in the desired repository. The locally defined rule will then take precedence over the global rule for that specific repository. The .cm automation file Schema The following sections are used in .cm file to describe the desired automations: manifest config automations manifest The first section in a gitstream.cm file is the manifest . manifest : version : 1.0 The only field required is version . Key Required Type Description manifest Y Map The manifest section root manifest.version Y String Specify the .cm spec version: 0.1, 1.0 The manifest version field is used to parse the .cm file, in the future if breaking changes are introduced to the parser then older automation will be still supported. config The config section is optional in the .cm file and is used to specify configuration for the way gitStream works. Key Type Default Scope Description config Map - per .cm file The config section, applies for the automations defined in the current file config.admin.users [String] [] gitstream.cm Admin user list (use the Git provider user names) config.ignore_files [String] [] per .cm file Exclude specific files config.ignore_repositories [String] [] per .cm file Exclude specific repositories config.user_mapping [String: String] [] per .cm file Key value list of Git user detailes and Git provider account names config.admin.users When specified in gitstream.cm the config.admin.users allows adding admin rights, when a PR changes the *.cm files only, if the user is listed in config.admin.users the PR will be then approved by gitStream. For example, setting popeye as admin: example config : admin : users : [ 'popeye' ] This configuration is valid only when used in .cm/gitstream.cm , when defined in other .cm files this configuration is ignored. When you add a user to config.admin.users in your organization's cm repository, they are granted administrative privileges to CM changes across every repository in the organization. gitStream evaluates CM rules in the individual repository and your organization's cm repository to determine admin users. config.ignore_files The config.ignore_files supports glob pattern matching that contains list of files to ignore, for example: example config : ignore_files : - 'yarn.lock' - 'package-lock.json' - 'openapi.json' - 'ui/src/**/*Model.d.ts' config.ignore_repositories The config.ignore_repositories contains list of repositories to ignore, for example: example config : ignore_repositories : - services - common For the listed repositories, the automation defined in the CM file shall not apply. config.user_mapping Accepts list of key value strings. For example, when using rankByGitBlame or explainRankByGitBlame Git users are mapped to their matching Git provider accounts based on the Git details. The automatic mapping can sometimes result with the wrong account or fail to find a proper mapping, in these cases you can configure the config.user_mapping . This allows you to map confusing Git user into their specific accounts and dump some irrelevant accounts: example config : user_mapping : - 'Popeye Man <popeye@invalid.com>' : 'popeye-the-salyor-man' # (1) - 'Popeye Man <popeye2@invalid.com>' : 'popeye-the-salyor-man' # (2) - 'olive <olive@invalid.com>' : null # (3) Map Git user signature to the correct Git provider user name (e.g. GitHub) Map Git user signature to the correct Git provider user name (e.g. GitHub) Mapping to null removes this Git user from the suggested results When using rankByGitBlame to assign reviewers automatically with add-reviewers@v1 then mapping users to null is a way to prevent the automatic mapping in certain cases, like in your example contributors that are not longer part of the team. On the other hand, when using explainRankByGitBlame with add-comment@v1 it still shows these users details in the PR comment suggestion as this info might be valuable by itself. - action : add-reviewers@v1 args : # (1) reviewers : {{ repo | rankByGitBlame ( gt = 25 ) }} - action : add-comment@v1 args : # (2) comment : | {{ repo | explainRankByGitBlame ( gt = 25 ) }} rankByGitBlame will drop null users explainRankByGitBlame will NOT drop null users automations The automations section defines the automations and their conditions. automations : mark_small_pr : if : - {{ checks.size.is.xsmall }} run : - action : add-label@v1 args : label : xsmall Each automation includes its name, and few fields: if and run . Key Required Type Description automations Y Map The automations section root automations.NAME Y Map User defined name of the automation, can be any string automations.NAME.if Y Map List of conditions with AND relationship automations.NAME.run Y Map Actions to run if all conditions are met, invoked one by one The if field includes the list of conditions. The conditions are checked when a pull request is opened or changed, if all the conditions pass, the automation is executed. The run field includes the automation to execute. It includes the following fields: Key Required Type Description action Y String The action pointer engine N String The action engine, default is gitstream args N List The action inputs list For gitstream engine, the action is specified by: name@version gitStream supported actions, see actions . Reusing checks You can define an accessory section, e.g. checks , that defines common conditions, and reuse. size : is : small : {{ branch.diff.size < 20 }} medium : {{ branch.diff.size >= 20 and branch.diff.size < 100 }} large : {{ branch.diff.size >= 100 }} automations : approve_small : if : - {{ size.is.small }} run : - action : approve@v1 mark_small_medium : if : # Check that the PR is either small or medium size - {{ size.is.small or size.is.medium }} # AND its less than 5 minutes review (estimated) - {{ branch | estimatedReviewTime <= 5 }} run : - action : add-label@v1 args : label : 'good-size'","title":"Configuration"},{"location":"cm-file/#overview","text":"Continuous Merge automation files have a .cm extension. In a repository, gitStream loads and parse the .cm directory, which can have multiple automation files, each of which is evaluated independently. You can edit the .cm files and add your own checks and rules. Check out the Automation examples .","title":"Overview"},{"location":"cm-file/#automation-rules","text":"There are two types of automation rules: repository level rules and organization level rules. Repository level rules are set by creating a special .cm directory in the repository root. Automation rules are specified in files in this directory, which can have any name but must end with .cm . Organization level rules are defined by creating a special repository named cm in the organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected. When organization level rules are defines, repository level automation shall take precedence and override organization automation when having the same identifier. An automation identifier is a composition of the CM file name and the automation name. For example when safe_changes is defined in gitstream.cm then the automation identifier shall be gitstream/safe_changes Tip You can exclude certain repositories per automation file using the config.ignore_repositories","title":"Automation rules"},{"location":"cm-file/#repository-automation-rules","text":"Repository automation rules are set by creating a special .cm directory in your repository root. Automation rules are specified in files in this directory, these files can have any name but must end with .cm . By default, you start with a single automation file .cm/gitstream.cm . Every file is parsed independently, and the parsing results are combined and executed. Specifically: Automation rules are allowed to have same name in different .cm files The config section is defined per .cm file (except config.admin ) Any accessory expression defined in each file scope, therefore cannot be reused in another file (but it can be duplicated) When configured correctly, your repository directory structure should look like that (for GitHub): Repsository automation rules . \u251c\u2500 .cm/ \u2502 \u2514\u2500 *.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml Note The .cm/gitstream.cm is special, as it allows for repository level configuration such as config.admin .","title":"Repository automation rules"},{"location":"cm-file/#organization-automation-rules","text":"Organization automation rules are defined by creating a special repository cm in your organization or group. In this repository, you can add CM automation files, which will apply to all the repositories that gitStream app is connected. When configured correctly, the cm repository directory structure should look like that (for GitHub): Repsository automation rules . \u251c\u2500 *.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml For each PR the following automation rules are applied: Repository level rules Organization level rules, unless with the same identifier as a repository level automation When organization level rules are defined, then the CI/CD will be executed on the cm repository on behalf of the PR repository.","title":"Organization automation rules"},{"location":"cm-file/#setting-up-global-automation-rules","text":"By utilizing the following techniques, you can effectively combine and manage global and repository rules to customize the behavior of your automations to fit the specific requirements of your repositories: Global rules are defined in the configuration management cm repository and are applied to all repositories that are connected to gitStream. To exclude a specific repository from a global rule, you can create a configuration file in the cm repository and add a list of the unwanted repositories under the config.ignore_repositories property in the CM file. To override a global rule for a specific automation in a repository, you can duplicate the rule (both the file and automation name) and place it in the desired repository. The locally defined rule will then take precedence over the global rule for that specific repository.","title":"Setting up Global Automation rules"},{"location":"cm-file/#the-cm-automation-file","text":"","title":"The .cm automation file"},{"location":"cm-file/#schema","text":"The following sections are used in .cm file to describe the desired automations: manifest config automations","title":"Schema"},{"location":"cm-file/#manifest","text":"The first section in a gitstream.cm file is the manifest . manifest : version : 1.0 The only field required is version . Key Required Type Description manifest Y Map The manifest section root manifest.version Y String Specify the .cm spec version: 0.1, 1.0 The manifest version field is used to parse the .cm file, in the future if breaking changes are introduced to the parser then older automation will be still supported.","title":"manifest"},{"location":"cm-file/#config","text":"The config section is optional in the .cm file and is used to specify configuration for the way gitStream works. Key Type Default Scope Description config Map - per .cm file The config section, applies for the automations defined in the current file config.admin.users [String] [] gitstream.cm Admin user list (use the Git provider user names) config.ignore_files [String] [] per .cm file Exclude specific files config.ignore_repositories [String] [] per .cm file Exclude specific repositories config.user_mapping [String: String] [] per .cm file Key value list of Git user detailes and Git provider account names","title":"config"},{"location":"cm-file/#configadminusers","text":"When specified in gitstream.cm the config.admin.users allows adding admin rights, when a PR changes the *.cm files only, if the user is listed in config.admin.users the PR will be then approved by gitStream. For example, setting popeye as admin: example config : admin : users : [ 'popeye' ] This configuration is valid only when used in .cm/gitstream.cm , when defined in other .cm files this configuration is ignored. When you add a user to config.admin.users in your organization's cm repository, they are granted administrative privileges to CM changes across every repository in the organization. gitStream evaluates CM rules in the individual repository and your organization's cm repository to determine admin users.","title":"config.admin.users"},{"location":"cm-file/#configignore_files","text":"The config.ignore_files supports glob pattern matching that contains list of files to ignore, for example: example config : ignore_files : - 'yarn.lock' - 'package-lock.json' - 'openapi.json' - 'ui/src/**/*Model.d.ts'","title":"config.ignore_files"},{"location":"cm-file/#configignore_repositories","text":"The config.ignore_repositories contains list of repositories to ignore, for example: example config : ignore_repositories : - services - common For the listed repositories, the automation defined in the CM file shall not apply.","title":"config.ignore_repositories"},{"location":"cm-file/#configuser_mapping","text":"Accepts list of key value strings. For example, when using rankByGitBlame or explainRankByGitBlame Git users are mapped to their matching Git provider accounts based on the Git details. The automatic mapping can sometimes result with the wrong account or fail to find a proper mapping, in these cases you can configure the config.user_mapping . This allows you to map confusing Git user into their specific accounts and dump some irrelevant accounts: example config : user_mapping : - 'Popeye Man <popeye@invalid.com>' : 'popeye-the-salyor-man' # (1) - 'Popeye Man <popeye2@invalid.com>' : 'popeye-the-salyor-man' # (2) - 'olive <olive@invalid.com>' : null # (3) Map Git user signature to the correct Git provider user name (e.g. GitHub) Map Git user signature to the correct Git provider user name (e.g. GitHub) Mapping to null removes this Git user from the suggested results When using rankByGitBlame to assign reviewers automatically with add-reviewers@v1 then mapping users to null is a way to prevent the automatic mapping in certain cases, like in your example contributors that are not longer part of the team. On the other hand, when using explainRankByGitBlame with add-comment@v1 it still shows these users details in the PR comment suggestion as this info might be valuable by itself. - action : add-reviewers@v1 args : # (1) reviewers : {{ repo | rankByGitBlame ( gt = 25 ) }} - action : add-comment@v1 args : # (2) comment : | {{ repo | explainRankByGitBlame ( gt = 25 ) }} rankByGitBlame will drop null users explainRankByGitBlame will NOT drop null users","title":"config.user_mapping"},{"location":"cm-file/#automations","text":"The automations section defines the automations and their conditions. automations : mark_small_pr : if : - {{ checks.size.is.xsmall }} run : - action : add-label@v1 args : label : xsmall Each automation includes its name, and few fields: if and run . Key Required Type Description automations Y Map The automations section root automations.NAME Y Map User defined name of the automation, can be any string automations.NAME.if Y Map List of conditions with AND relationship automations.NAME.run Y Map Actions to run if all conditions are met, invoked one by one The if field includes the list of conditions. The conditions are checked when a pull request is opened or changed, if all the conditions pass, the automation is executed. The run field includes the automation to execute. It includes the following fields: Key Required Type Description action Y String The action pointer engine N String The action engine, default is gitstream args N List The action inputs list For gitstream engine, the action is specified by: name@version gitStream supported actions, see actions .","title":"automations"},{"location":"cm-file/#reusing-checks","text":"You can define an accessory section, e.g. checks , that defines common conditions, and reuse. size : is : small : {{ branch.diff.size < 20 }} medium : {{ branch.diff.size >= 20 and branch.diff.size < 100 }} large : {{ branch.diff.size >= 100 }} automations : approve_small : if : - {{ size.is.small }} run : - action : approve@v1 mark_small_medium : if : # Check that the PR is either small or medium size - {{ size.is.small or size.is.medium }} # AND its less than 5 minutes review (estimated) - {{ branch | estimatedReviewTime <= 5 }} run : - action : add-label@v1 args : label : 'good-size'","title":"Reusing checks"},{"location":"cm-syntax/","text":"Deprecated. See: /how-it-works","title":"Cm syntax"},{"location":"context-variables/","text":"Context variables Context variable are the inputs for the automation conditions or checks. Note Items marked with are under development and are not available yet. Overview Context gitStream includes a collection of variables called contexts. branch files source repo pr Structures The following structures are used in the context objects: GitBlame Check Contributor FileDiff FileMetadata Comment conversations Example of a context object Partial example of a context object for a PR that changed few lines in a README.md file: { \"branch\" : { \"name\" : \"new-feature-branch\" , \"base\" : \"main\" , \"diff\" : { \"size\" : 50 , \"files_metadata\" : [ { \"original_file\" : \"README.md\" , \"new_file\" : \"README.md\" , \"deletions\" : 0 , \"additions\" : 2 } ] }, \"num_of_commits\" : 1 }, \"source\" : { \"diff\" : { \"files\" : [ { \"original_file\" : \"README.md\" , \"new_file\" : \"README.md\" , \"diff\" : \"@@ -10,3 +10,5 @@ This project \\n+\\n+## Intro\" , \"original_content\" : \"This project \\n\" , \"new_content\" : \"This project \\n\\n## Intro\" } ] } }, \"repo\" : { \"contributors\" : { \"popeye\" : \"46\" , \"olive\" : \"6\" } }, \"files\" : [ \"README.md\" ] } Reference branch The branch context contains info regarding the branch changes compared to the base branch. Note compared to the source context does not include actual source code. Values Type Description branch Map Includes the info related to the current branch branch.author String The branch author (the user that did first commit in the branch). The formatted like author in git-log , e.g. Popeye <popeye@acme.com> branch.author_name String The branch author name branch.author_email String The branch author email branch.base String The main branch, main branch.commits.messages [String] A list with all the commit messages in this branch branch.diff.size Integer The sum of line changed: additions, edits and deletions branch.diff.files_metadata FileMetadata List of changed files including their relative path branch.name String The current branch, feature-123-branch branch.num_of_commits Integer The number of commits in the branch The branch context doesn't include any source code, but only related metadata. Example for using branch.name and branch.author to automatically approve and merge version bumps. automations : dependabot : if : - {{ branch.name | includes ( term = \"dependabot\" ) }} - {{ branch.author | includes ( term = \"dependabot\" ) }} run : - action : approve@v1 - action : add-label@v1 args : label : \"approved-dependabot\" - action : merge@v1 args : wait_for_all_checks : true squash_on_merge : true files The files context includes the list of changed files in the branch compared to the main branch. Values Type Description files [String] List of all changed files with their full path For example, a typical files context can look like this: [ \"README.md\" , \"package.json\" , \"src/app.js\" , \"src/index.js\" , \"docs/examples.md\" ] Example for checking if certain changes are made: automations : ui_review : if : - {{ files | match ( list = ui_templates_files ) | some }} run : - action : add-reviewers@v1 args : reviewers : [ GitHubUser1 , GitHubUser2 ] ui_templates_files : - resources/app/ui_template.yml - resources/app/role_template.yml - resources/app/account_template.yml pr The pr context includes metadata related to the pull request. Values Type Description pr Map Includes the info related to the PR pr.approvals [String] The of reviewers that approved the PR pr.author String The PR author name pr.author_teams String The teams which the PR author is member of pr.checks [ Check ] List of checks, names and status pr.comments [ Comment ] List of PR comments objects pr.conversations [ Conversation ] List of PR conversation objects, usually when reviewer have comments about the source code pr.created_at String The date and time the PR was created pr.draft Bool true when the PR is marked as Draft/WIP pr.description String The PR description text pr.labels [String] The labels that are attached to the PR pr.provider String The Git cloud provider name, e.g. GitHub , GitLab etc. pr.reviewers [String] The list of reviewers set for this PR pr.status String The PR status: open , closed and merged pr.target String The branch the PR is intended merged into pr.title String The PR title pr.requested_changes [String] List of users that requested changes pr.reviews [ Review ] List of PR reviews, relevant in GitHub pr.updated_at String The date and time the PR was last updated Example for checking the PR title includes a Jira ticket: automations : check_jira_ticket : if : - {{ not has.jira_ticket }} run : - action : add-label@v1 args : label : \"missing-ticket\" color : 'F6443B' has : jira_ticket : {{ pr.title | includes ( regex = r / ^\\ [ ?\\ w { 3 , 4 }- \\ d { 1 , 6 } \\ ] ? ( \\ s | -| _ ) . { 20 ,} $ /) }} repo The repo context includes metadata related to the repo. Values Type Description repo Map Includes the info related to the current repo repo.git_activity GitActivity Per file and user, the number of lines changed every week for the last 52 weeks repo.age Integer Number of days since first commit (of any user) repo.author_age Integer number of days since first commit to this repo repo.blame GitBlame The percentage each user's lines in a file, the list includes all changed files in the branch. The list is sorted by the ratio field repo.contributors Contributor List of contributors in the repo repo.name String Repository name source The source context includes a list of FileDiff objects that can be used to get insights based on code changes. The changes compared to the latest main branch. Values Type Description source.diff.files FileDiff List of changed files with their code changes The source context include all code changes, it is not safe to share it with unknown services. Check structure Coming soon { \"name\" : S tr i n g , # The check na me \"status\" : S tr i n g , # The check s tatus : `queued` , `i n _progress` , `comple te d` \"conclusion\" : S tr i n g , # The check co n clusio n : `ac t io n _required` , `ca n celled` , ` fa ilure` ` neutral ` , `success` , `skipped` , `s tale ` , ` t imed_ou t ` } Comment structure { \"commenter\" : S tr i n g , # The user t ha t add t he comme nt \"content\" : S tr i n g , # The comme nt body \"created_at\" : S tr i n g , # The t ime o n which t he comme nt was crea te d \"updated_at\" : S tr i n g , # The t ime o n which t he comme nt was las t upda te d } Conversation structure { \"commenter\" : S tr i n g , # The user t ha t add t he comme nt \"content\" : S tr i n g , # The comme nt body \"created_at\" : S tr i n g , # The t ime o n which t he comme nt was crea te d \"updated_at\" : S tr i n g , # The t ime o n which t he comme nt was upda te d \"start_line\" : I nte ger , # The f irs t li ne marked f or t his comme nt \"end_line\" : I nte ger , # The las t li ne marked f or t his comme nt \"is_resolved\" : Boolea n # ` true ` whe n marked as resolved } Contributor structure The repo.contributors mapping includes a list of Contributor , where the user name is used as dynamic key: { USER_NAME : I nte ger # Number o f commi ts } FileDiff structure The source.diff.files mapping includes a list of FileDiff : { \"diff\" : S tr i n g , # The co ntent i n di ff f orma t `+` f or addi t io ns , ` - ` f or dele t io ns \"new_content\" : S tr i n g , # The ne w co ntent i n t his bra n ch \"new_file\" : S tr i n g , # The na me o f t he f ile a fter t he cha n ges , i n cludi n g i ts pa t h \"original_content\" : S tr i n g , # The co ntent as is i n t he `mai n ` bra n ch \"original_file\" : S tr i n g , # The na me o f t he f ile be f ore t he cha n ges , i n cludi n g i ts pa t h } FileMetadata structure The branch.diff.files_metadata mapping includes a list of FileMetadata : { \"additions\" : I nte ger , # The nu mber o f li nes edi te d or added t o t he f ile \"deletions\" : I nte ger , # The nu mber o f li nes removed fr om t he f ile \"file\" : S tr i n g , # The na me o f t he f ile be f ore t he cha n ges , i n cludi n g i ts pa t h } For example, sum additions in javascript code files: {{ branch.diff.files_metadata | filter ( attr = 'new_file' , regex = r / \\ .js $|\\ .ts $ /) | map ( attr = 'additions' ) | sum }} GitActivity structure This structure include per changed file, for every user, the number of lines changed every week for the last 52 weeks. { FILE_NAME : # The f ile na me a n d pa t h { # The gi t user ide nt i f ier (S tr i n g) GIT_USER : { \"week_INDEX\" : I nte ger # Number o f li nes cha n ged t ha t week # ... f or t he las t 52 weeks } } } For example: { \"src/utils/service.js\" : { \"popeye <popeye@acme.com>\" : { \"week_1\" : 20 , \"week_2\" : 15 , \"week_10\" : 250 }, \"olive <olive@acme.com>\" : { \"week_1\" : 3 , \"week_3\" : 50 , \"week_52\" : 250 } }, \"README.md\" : { \"popeye <popeye@acme.com>\" : { \"week_2\" : 15 , \"week_3\" : 10 } } } GitBlame structure For each file, a list of user's blame ratio. { FILE_NAME : # The f ile na me a n d pa t h { # The gi t user ide nt i f ier (S tr i n g) GIT_USER : I nte ger , # Prece nta ge 0-100 , ra t io o f user's li nes / t o tal li nes i n f ile } } For example: { \"src/utils/service.js\" : { \"popeye <popeye@acme.com>\" : 78 , \"olive <olive@acme.com>\" : 22 , }, \"README.md\" : { \"popeye <popeye@acme.com>\" : 13 , \"olive <olive@acme.com>\" : 22 , \"brutus <brutus@acme.com>\" : 65 , } } Review structure { \"commenter\" : S tr i n g , # The user t ha t add t he comme nt \"content\" : S tr i n g , # The comme nt body \"created_at\" : S tr i n g , # The t ime o n which t he comme nt was crea te d \"state\" : S tr i n g , # Ei t her `approved` , `cha n ges_reques te d` , `comme nte d` , `pe n di n g` , `submi tte d` \"conversations\" : [ Co n versa t io n ], # Co n versa t io ns t ha t are relva nt t o t his Review fee dback }","title":"Context variables"},{"location":"context-variables/#context-variables","text":"Context variable are the inputs for the automation conditions or checks. Note Items marked with are under development and are not available yet.","title":"Context variables"},{"location":"context-variables/#overview","text":"","title":"Overview"},{"location":"context-variables/#context","text":"gitStream includes a collection of variables called contexts. branch files source repo pr","title":"Context"},{"location":"context-variables/#structures","text":"The following structures are used in the context objects: GitBlame Check Contributor FileDiff FileMetadata Comment conversations Example of a context object Partial example of a context object for a PR that changed few lines in a README.md file: { \"branch\" : { \"name\" : \"new-feature-branch\" , \"base\" : \"main\" , \"diff\" : { \"size\" : 50 , \"files_metadata\" : [ { \"original_file\" : \"README.md\" , \"new_file\" : \"README.md\" , \"deletions\" : 0 , \"additions\" : 2 } ] }, \"num_of_commits\" : 1 }, \"source\" : { \"diff\" : { \"files\" : [ { \"original_file\" : \"README.md\" , \"new_file\" : \"README.md\" , \"diff\" : \"@@ -10,3 +10,5 @@ This project \\n+\\n+## Intro\" , \"original_content\" : \"This project \\n\" , \"new_content\" : \"This project \\n\\n## Intro\" } ] } }, \"repo\" : { \"contributors\" : { \"popeye\" : \"46\" , \"olive\" : \"6\" } }, \"files\" : [ \"README.md\" ] }","title":"Structures"},{"location":"context-variables/#reference","text":"","title":"Reference"},{"location":"context-variables/#branch","text":"The branch context contains info regarding the branch changes compared to the base branch. Note compared to the source context does not include actual source code. Values Type Description branch Map Includes the info related to the current branch branch.author String The branch author (the user that did first commit in the branch). The formatted like author in git-log , e.g. Popeye <popeye@acme.com> branch.author_name String The branch author name branch.author_email String The branch author email branch.base String The main branch, main branch.commits.messages [String] A list with all the commit messages in this branch branch.diff.size Integer The sum of line changed: additions, edits and deletions branch.diff.files_metadata FileMetadata List of changed files including their relative path branch.name String The current branch, feature-123-branch branch.num_of_commits Integer The number of commits in the branch The branch context doesn't include any source code, but only related metadata. Example for using branch.name and branch.author to automatically approve and merge version bumps. automations : dependabot : if : - {{ branch.name | includes ( term = \"dependabot\" ) }} - {{ branch.author | includes ( term = \"dependabot\" ) }} run : - action : approve@v1 - action : add-label@v1 args : label : \"approved-dependabot\" - action : merge@v1 args : wait_for_all_checks : true squash_on_merge : true","title":"branch"},{"location":"context-variables/#files","text":"The files context includes the list of changed files in the branch compared to the main branch. Values Type Description files [String] List of all changed files with their full path For example, a typical files context can look like this: [ \"README.md\" , \"package.json\" , \"src/app.js\" , \"src/index.js\" , \"docs/examples.md\" ] Example for checking if certain changes are made: automations : ui_review : if : - {{ files | match ( list = ui_templates_files ) | some }} run : - action : add-reviewers@v1 args : reviewers : [ GitHubUser1 , GitHubUser2 ] ui_templates_files : - resources/app/ui_template.yml - resources/app/role_template.yml - resources/app/account_template.yml","title":"files"},{"location":"context-variables/#pr","text":"The pr context includes metadata related to the pull request. Values Type Description pr Map Includes the info related to the PR pr.approvals [String] The of reviewers that approved the PR pr.author String The PR author name pr.author_teams String The teams which the PR author is member of pr.checks [ Check ] List of checks, names and status pr.comments [ Comment ] List of PR comments objects pr.conversations [ Conversation ] List of PR conversation objects, usually when reviewer have comments about the source code pr.created_at String The date and time the PR was created pr.draft Bool true when the PR is marked as Draft/WIP pr.description String The PR description text pr.labels [String] The labels that are attached to the PR pr.provider String The Git cloud provider name, e.g. GitHub , GitLab etc. pr.reviewers [String] The list of reviewers set for this PR pr.status String The PR status: open , closed and merged pr.target String The branch the PR is intended merged into pr.title String The PR title pr.requested_changes [String] List of users that requested changes pr.reviews [ Review ] List of PR reviews, relevant in GitHub pr.updated_at String The date and time the PR was last updated Example for checking the PR title includes a Jira ticket: automations : check_jira_ticket : if : - {{ not has.jira_ticket }} run : - action : add-label@v1 args : label : \"missing-ticket\" color : 'F6443B' has : jira_ticket : {{ pr.title | includes ( regex = r / ^\\ [ ?\\ w { 3 , 4 }- \\ d { 1 , 6 } \\ ] ? ( \\ s | -| _ ) . { 20 ,} $ /) }}","title":"pr"},{"location":"context-variables/#repo","text":"The repo context includes metadata related to the repo. Values Type Description repo Map Includes the info related to the current repo repo.git_activity GitActivity Per file and user, the number of lines changed every week for the last 52 weeks repo.age Integer Number of days since first commit (of any user) repo.author_age Integer number of days since first commit to this repo repo.blame GitBlame The percentage each user's lines in a file, the list includes all changed files in the branch. The list is sorted by the ratio field repo.contributors Contributor List of contributors in the repo repo.name String Repository name","title":"repo"},{"location":"context-variables/#source","text":"The source context includes a list of FileDiff objects that can be used to get insights based on code changes. The changes compared to the latest main branch. Values Type Description source.diff.files FileDiff List of changed files with their code changes The source context include all code changes, it is not safe to share it with unknown services.","title":"source"},{"location":"context-variables/#check-structure","text":"Coming soon { \"name\" : S tr i n g , # The check na me \"status\" : S tr i n g , # The check s tatus : `queued` , `i n _progress` , `comple te d` \"conclusion\" : S tr i n g , # The check co n clusio n : `ac t io n _required` , `ca n celled` , ` fa ilure` ` neutral ` , `success` , `skipped` , `s tale ` , ` t imed_ou t ` }","title":"Check structure"},{"location":"context-variables/#comment-structure","text":"{ \"commenter\" : S tr i n g , # The user t ha t add t he comme nt \"content\" : S tr i n g , # The comme nt body \"created_at\" : S tr i n g , # The t ime o n which t he comme nt was crea te d \"updated_at\" : S tr i n g , # The t ime o n which t he comme nt was las t upda te d }","title":"Comment structure"},{"location":"context-variables/#conversation-structure","text":"{ \"commenter\" : S tr i n g , # The user t ha t add t he comme nt \"content\" : S tr i n g , # The comme nt body \"created_at\" : S tr i n g , # The t ime o n which t he comme nt was crea te d \"updated_at\" : S tr i n g , # The t ime o n which t he comme nt was upda te d \"start_line\" : I nte ger , # The f irs t li ne marked f or t his comme nt \"end_line\" : I nte ger , # The las t li ne marked f or t his comme nt \"is_resolved\" : Boolea n # ` true ` whe n marked as resolved }","title":"Conversation structure"},{"location":"context-variables/#contributor-structure","text":"The repo.contributors mapping includes a list of Contributor , where the user name is used as dynamic key: { USER_NAME : I nte ger # Number o f commi ts }","title":"Contributor structure"},{"location":"context-variables/#filediff-structure","text":"The source.diff.files mapping includes a list of FileDiff : { \"diff\" : S tr i n g , # The co ntent i n di ff f orma t `+` f or addi t io ns , ` - ` f or dele t io ns \"new_content\" : S tr i n g , # The ne w co ntent i n t his bra n ch \"new_file\" : S tr i n g , # The na me o f t he f ile a fter t he cha n ges , i n cludi n g i ts pa t h \"original_content\" : S tr i n g , # The co ntent as is i n t he `mai n ` bra n ch \"original_file\" : S tr i n g , # The na me o f t he f ile be f ore t he cha n ges , i n cludi n g i ts pa t h }","title":"FileDiff structure"},{"location":"context-variables/#filemetadata-structure","text":"The branch.diff.files_metadata mapping includes a list of FileMetadata : { \"additions\" : I nte ger , # The nu mber o f li nes edi te d or added t o t he f ile \"deletions\" : I nte ger , # The nu mber o f li nes removed fr om t he f ile \"file\" : S tr i n g , # The na me o f t he f ile be f ore t he cha n ges , i n cludi n g i ts pa t h } For example, sum additions in javascript code files: {{ branch.diff.files_metadata | filter ( attr = 'new_file' , regex = r / \\ .js $|\\ .ts $ /) | map ( attr = 'additions' ) | sum }}","title":"FileMetadata structure"},{"location":"context-variables/#gitactivity-structure","text":"This structure include per changed file, for every user, the number of lines changed every week for the last 52 weeks. { FILE_NAME : # The f ile na me a n d pa t h { # The gi t user ide nt i f ier (S tr i n g) GIT_USER : { \"week_INDEX\" : I nte ger # Number o f li nes cha n ged t ha t week # ... f or t he las t 52 weeks } } } For example: { \"src/utils/service.js\" : { \"popeye <popeye@acme.com>\" : { \"week_1\" : 20 , \"week_2\" : 15 , \"week_10\" : 250 }, \"olive <olive@acme.com>\" : { \"week_1\" : 3 , \"week_3\" : 50 , \"week_52\" : 250 } }, \"README.md\" : { \"popeye <popeye@acme.com>\" : { \"week_2\" : 15 , \"week_3\" : 10 } } }","title":"GitActivity structure"},{"location":"context-variables/#gitblame-structure","text":"For each file, a list of user's blame ratio. { FILE_NAME : # The f ile na me a n d pa t h { # The gi t user ide nt i f ier (S tr i n g) GIT_USER : I nte ger , # Prece nta ge 0-100 , ra t io o f user's li nes / t o tal li nes i n f ile } } For example: { \"src/utils/service.js\" : { \"popeye <popeye@acme.com>\" : 78 , \"olive <olive@acme.com>\" : 22 , }, \"README.md\" : { \"popeye <popeye@acme.com>\" : 13 , \"olive <olive@acme.com>\" : 22 , \"brutus <brutus@acme.com>\" : 65 , } }","title":"GitBlame structure"},{"location":"context-variables/#review-structure","text":"{ \"commenter\" : S tr i n g , # The user t ha t add t he comme nt \"content\" : S tr i n g , # The comme nt body \"created_at\" : S tr i n g , # The t ime o n which t he comme nt was crea te d \"state\" : S tr i n g , # Ei t her `approved` , `cha n ges_reques te d` , `comme nte d` , `pe n di n g` , `submi tte d` \"conversations\" : [ Co n versa t io n ], # Co n versa t io ns t ha t are relva nt t o t his Review fee dback }","title":"Review structure"},{"location":"custom-filters-v1/","text":"Custom filters V1 Custom filters are JavaScript code snippets that will be embedded into gitStream's functionality after a review and approval process by our engineers. Attention Coming soon Creating filters Filters can have input parameters of any type allowed in the .cm file. The 1st argument can be piped to the filter, and the rest must be used as conventional function arguments. Filters must return a valid JavaScript type (i.e., Bool, Int, String, Object, etc...) Dependencies Attention TBD Consult with gitStream's team if the custom filter requires any dependencies. Examples Basic custom filter The following example shows a filter that receives a string and returns its length. const strLengthFilter = ( str : string ) => { return str . length ; } Filter usage in gitStream Once the filter has been added to gitStream, it can be used as any other high-level filter. Since it receives only one argument, it can be piped or passed as a function argument, for example: {{ \"my string\" | strLengthFilter }} , or {{ strLengthFilter(\"my string\") }} Custom filter with context variable The following example shows a filter receiving the pr context and a commenter name as input. It returns true if the last general comment 's author equals the commenter name and the content contains the string \"foo\". Otherwise, it returns false . const myFilter = ( pr_context : any , commenter : string ) => { const comments = pr_context . comments ; if ( ! comments || comments . length === 0 ) { return false ; // If there are no comments or the comments array is empty, return false } const lastComment = comments [ comments . length - 1 ]; return ( lastComment . commenter === commenter && lastComment . content . includes ( 'foo' )); // check the criteria for the last comment }; Filter usage in gitStream Approve the PR if the value of myFilterOutput is true : automations : # approve the PR if the value of `myFilterOutput` is `true`. if : - {{ pr | myFilter ( \"bar\" ) }} run : - action : approve@v1 Local testing Attention TBD","title":"Custom filters V1"},{"location":"custom-filters-v1/#custom-filters-v1","text":"Custom filters are JavaScript code snippets that will be embedded into gitStream's functionality after a review and approval process by our engineers. Attention Coming soon","title":"Custom filters V1"},{"location":"custom-filters-v1/#creating-filters","text":"Filters can have input parameters of any type allowed in the .cm file. The 1st argument can be piped to the filter, and the rest must be used as conventional function arguments. Filters must return a valid JavaScript type (i.e., Bool, Int, String, Object, etc...)","title":"Creating filters"},{"location":"custom-filters-v1/#dependencies","text":"Attention TBD Consult with gitStream's team if the custom filter requires any dependencies.","title":"Dependencies"},{"location":"custom-filters-v1/#examples","text":"","title":"Examples"},{"location":"custom-filters-v1/#basic-custom-filter","text":"The following example shows a filter that receives a string and returns its length. const strLengthFilter = ( str : string ) => { return str . length ; }","title":"Basic custom filter"},{"location":"custom-filters-v1/#filter-usage-in-gitstream","text":"Once the filter has been added to gitStream, it can be used as any other high-level filter. Since it receives only one argument, it can be piped or passed as a function argument, for example: {{ \"my string\" | strLengthFilter }} , or {{ strLengthFilter(\"my string\") }}","title":"Filter usage in gitStream"},{"location":"custom-filters-v1/#custom-filter-with-context-variable","text":"The following example shows a filter receiving the pr context and a commenter name as input. It returns true if the last general comment 's author equals the commenter name and the content contains the string \"foo\". Otherwise, it returns false . const myFilter = ( pr_context : any , commenter : string ) => { const comments = pr_context . comments ; if ( ! comments || comments . length === 0 ) { return false ; // If there are no comments or the comments array is empty, return false } const lastComment = comments [ comments . length - 1 ]; return ( lastComment . commenter === commenter && lastComment . content . includes ( 'foo' )); // check the criteria for the last comment };","title":"Custom filter with context variable"},{"location":"custom-filters-v1/#filter-usage-in-gitstream_1","text":"Approve the PR if the value of myFilterOutput is true : automations : # approve the PR if the value of `myFilterOutput` is `true`. if : - {{ pr | myFilter ( \"bar\" ) }} run : - action : approve@v1","title":"Filter usage in gitStream"},{"location":"custom-filters-v1/#local-testing","text":"Attention TBD","title":"Local testing"},{"location":"custom-filters/","text":"Custom filters Custom filters are implemented in JavaScript. Attention Coming soon You can add custom filters by editing the .cm/filters.js file in your repo. . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm \u2502 \u2514\u2500 filters.js Adding filters Filters can have input arguments and return a result which can be any valid JavaScript type. An example for a .cm/filters.js : export default { // The includes() method determines whether an array includes a // certain value among its entries, returning true or false. myIncludes : ( list , term ) => { return list . includes ( term ); }, // Determine if a number is even or odd isOdd : ( n ) => { return parseInt ( n ) % 2 == 0 ; } } Once filters are added it can be used in the .cm files, for example using isOdd filter looks like this: {{ branch.diff.size | isOdd }} Using npm packages The file is loaded by a node.js runtime, the following packages are pre installed and can be imported and used: child_process Using external tools results Tip: cache result to local file system and reuse in CI/CD const { exec } = require ( 'child_process' ); exec ( 'npm run test | wc -l' , ( err , stdout , stderr ) => { if ( err ) { // node couldn't execute the command return ; } // the *entire* stdout and stderr (buffered) console . log ( `stdout: ${ stdout } ` ); console . log ( `stderr: ${ stderr } ` ); return 123 ; }); For example: # access coverage results coverage : is : # npm run test -> /file/here enough : {{ source | my_coverage > 80 }} # 2 user's filter","title":"Custom filters"},{"location":"custom-filters/#custom-filters","text":"Custom filters are implemented in JavaScript. Attention Coming soon You can add custom filters by editing the .cm/filters.js file in your repo. . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm \u2502 \u2514\u2500 filters.js","title":"Custom filters"},{"location":"custom-filters/#adding-filters","text":"Filters can have input arguments and return a result which can be any valid JavaScript type. An example for a .cm/filters.js : export default { // The includes() method determines whether an array includes a // certain value among its entries, returning true or false. myIncludes : ( list , term ) => { return list . includes ( term ); }, // Determine if a number is even or odd isOdd : ( n ) => { return parseInt ( n ) % 2 == 0 ; } } Once filters are added it can be used in the .cm files, for example using isOdd filter looks like this: {{ branch.diff.size | isOdd }}","title":"Adding filters"},{"location":"custom-filters/#using-npm-packages","text":"The file is loaded by a node.js runtime, the following packages are pre installed and can be imported and used: child_process","title":"Using npm packages"},{"location":"custom-filters/#using-external-tools-results","text":"Tip: cache result to local file system and reuse in CI/CD const { exec } = require ( 'child_process' ); exec ( 'npm run test | wc -l' , ( err , stdout , stderr ) => { if ( err ) { // node couldn't execute the command return ; } // the *entire* stdout and stderr (buffered) console . log ( `stdout: ${ stdout } ` ); console . log ( `stderr: ${ stderr } ` ); return 123 ; }); For example: # access coverage results coverage : is : # npm run test -> /file/here enough : {{ source | my_coverage > 80 }} # 2 user's filter","title":"Using external tools results"},{"location":"dry-run-mode/","text":"How to Test Your Automation By default, gitStream runs all applicable automations for every new PR and change to existing PR. If you want to test and experiment with new rules, gitStream supports a dry-run mode that will avoid making changes to your PRs. When you commit changes to any CM files found inside your repo's .cm/ directory, gitStream will switch to dry-run mode. In dry-run mode, gitStream won't execute any automation rules on the PR. Instead, gitStream will parse all applicable automation rules and post a comment to the PR discussion that describes the actions that will be taken for normal PRs. A new comment will be added after every new commit. Note When in dry-run mode, incoming changes to the CM files are ignored. In other words, new automations and configurations won't take effect until you merge the PR. Once you are satisfied with the results, you can merge your CM changes into the main branch to enable the new configurations.","title":"How to Test Your Automations"},{"location":"dry-run-mode/#how-to-test-your-automation","text":"By default, gitStream runs all applicable automations for every new PR and change to existing PR. If you want to test and experiment with new rules, gitStream supports a dry-run mode that will avoid making changes to your PRs. When you commit changes to any CM files found inside your repo's .cm/ directory, gitStream will switch to dry-run mode. In dry-run mode, gitStream won't execute any automation rules on the PR. Instead, gitStream will parse all applicable automation rules and post a comment to the PR discussion that describes the actions that will be taken for normal PRs. A new comment will be added after every new commit. Note When in dry-run mode, incoming changes to the CM files are ignored. In other words, new automations and configurations won't take effect until you merge the PR. Once you are satisfied with the results, you can merge your CM changes into the main branch to enable the new configurations.","title":"How to Test Your Automation"},{"location":"examples/","text":"gitStream Quickstart Examples This page contains common gitStream configurations that are a great place to get started with gitStream. For a more detailed list, check out the gitStream automation library . How to use these examples. These examples are all complete gitStream configuration files that you can download directly via the buttons below the examples and upload to the .cm directory of your repo. Alternatively, you can copy and paste the individual automations, but make sure you include all required declarations and any related custom expressions from the configurations to ensure they work properly. Assign Code Experts When someone applies a suggest-reviewers label to a PR, use codeExperts to assign recommended reviewers and post a comment with the explainCodeExperts automation action. More details here. Assign Code Experts # -*- mode: yaml -*- manifest : version : 1.0 automations : assign_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Download this example as a CM file. Request Changes for Deprecated Components Request changes when a PR includes one or more deprecated components. More details here. Change Deprecated Components # -*- mode: yaml -*- manifest : version : 1.0 automations : # Request changes when a PR includes deprecated components. # This requires the `item` custom expression found at the bottom of this file. {% for item in deprecated %} # Automation names must be unique, so this adds an iterator index to each instance catch_deprecated_components_ {{ loop .index }} : # Triggered when any of the modified files use a deprecated component if : - {{ source.diff.files | matchDiffLines ( regex = item.regex ) | some }} # Apply a deprecated-component label, request changes, and post a comment with an explanation. run : - action : add-label@v1 args : label : 'deprecated-component' color : '#FF0000' - action : request-changes@v1 args : comment : | ` {{ item.old }} ` component is deprecated, use ` {{ item.new }} ` instead {% endfor %} # These are the deprecated files that are evaluated in catch_deprecated_components deprecated : - regex : r/oldAPI/ old : oldAPI new : newAPI - regex : r/anotherOldAPI/ old : anotherOldAPI new : anotherNewAPI Download this example as a CM file. Review Sensitive Files Require sensitive files from a pre-determined list to be reviewed by a specific team. More details here Review Sensitive Files # -*- mode: yaml -*- manifest : version : 1.0 automations : # Assign special teams to review sensitive files. # This requires the `sensitive` custom expression found at the bottom of this file. review_sensitive_files : # For all files listed in the sensitive custom expression. if : - {{ files | match ( list = sensitive_files ) | some }} run : # Add reviewers from the dev-leads team, and require two approvals # Modify `my-organization/security` to match your organization. - action : add-reviewers@v1 args : reviewers : [ my-organization/security ] - action : set-required-approvals@v1 args : approvals : 2 - action : add-comment@v1 args : comment : | This PR affects one or more sensitive files and requires review from the security team. # The `sensitive_file_review` automation requires this custom expression. # Modify this list to suit your security needs. sensitive_files : - src/app/auth/ - src/app/routing/ - src/app/resources/ Download this example as a CM file. Approve Safe Changes Automatically approve documentation, formatting, and test changes. More details here. Approve Safe Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : safe_changes : # Triggered for any changes that only affect formatting, documentation, tests, or images if : - {{ is .formatting or is .docs or is .tests or is .image }} # Apply a safe change label, approve the PR and explain why in a comment. run : - action : add-label@v1 args : label : 'safe-change' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR is considered a safe change and has been automatically approved. # These custom expressions are used in the safe_changes automation is : formatting : {{ source.diff.files | isFormattingChange }} docs : {{ files | allDocs }} tests : {{ files | allTests }} image : {{ files | allImages }} Download this example as a CM file. Provide Estimated Time to Review Label all PRs with an estimated number of minutes it would take someone to review. More details here. Provide Estimated Time to Review # -*- mode: yaml -*- manifest : version : 1.0 automations : estimated_time_to_review : if : - true run : - action : add-label@v1 args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} calc : etr : {{ branch | estimatedReviewTime }} Download this example as a CM file. Label Missing Jira Info Label PRs that don't reference a Jira ticket in the title or description. This uses regex to detect Jira ticket formats in the title (e.g. ABC-1234), and URLs to Jira tickets in the description. More details here. Label Missing Jira Info # -*- mode: yaml -*- manifest : version : 1.0 automations : label_missing_jira_info : # Triggered for PRs that don't have either a Jira ticket number in the title, # or a link to a Jira ticket in the PR description. if : - {{ not ( has.jira_ticket_in_title or has.jira_ticket_in_desc ) }} run : - action : add-label@v1 args : label : \"missing-jira\" color : 'F6443B' has : jira_ticket_in_title : {{ pr.title | includes ( regex = r / ^\\ [ ?\\ w { 3 , 4 }- \\ d { 1 , 6 } \\ ] ? ( \\ s | -| _ ) . { 1 ,} $ /) }} jira_ticket_in_desc : {{ pr.description | includes ( regex = r / atlassian.net \\ / browse \\ / \\ w { 1 ,}- \\ d { 3 , 4 }/) }} Download this example as a CM file. More examples Check out the gitStream automation library. Click here to find a more extensive list of automation examples.","title":"Quickstart Examples"},{"location":"examples/#gitstream-quickstart-examples","text":"This page contains common gitStream configurations that are a great place to get started with gitStream. For a more detailed list, check out the gitStream automation library . How to use these examples. These examples are all complete gitStream configuration files that you can download directly via the buttons below the examples and upload to the .cm directory of your repo. Alternatively, you can copy and paste the individual automations, but make sure you include all required declarations and any related custom expressions from the configurations to ensure they work properly.","title":"gitStream Quickstart Examples"},{"location":"examples/#assign-code-experts","text":"When someone applies a suggest-reviewers label to a PR, use codeExperts to assign recommended reviewers and post a comment with the explainCodeExperts automation action. More details here. Assign Code Experts # -*- mode: yaml -*- manifest : version : 1.0 automations : assign_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Download this example as a CM file.","title":"Assign Code Experts"},{"location":"examples/#request-changes-for-deprecated-components","text":"Request changes when a PR includes one or more deprecated components. More details here. Change Deprecated Components # -*- mode: yaml -*- manifest : version : 1.0 automations : # Request changes when a PR includes deprecated components. # This requires the `item` custom expression found at the bottom of this file. {% for item in deprecated %} # Automation names must be unique, so this adds an iterator index to each instance catch_deprecated_components_ {{ loop .index }} : # Triggered when any of the modified files use a deprecated component if : - {{ source.diff.files | matchDiffLines ( regex = item.regex ) | some }} # Apply a deprecated-component label, request changes, and post a comment with an explanation. run : - action : add-label@v1 args : label : 'deprecated-component' color : '#FF0000' - action : request-changes@v1 args : comment : | ` {{ item.old }} ` component is deprecated, use ` {{ item.new }} ` instead {% endfor %} # These are the deprecated files that are evaluated in catch_deprecated_components deprecated : - regex : r/oldAPI/ old : oldAPI new : newAPI - regex : r/anotherOldAPI/ old : anotherOldAPI new : anotherNewAPI Download this example as a CM file.","title":"Request Changes for Deprecated Components"},{"location":"examples/#review-sensitive-files","text":"Require sensitive files from a pre-determined list to be reviewed by a specific team. More details here Review Sensitive Files # -*- mode: yaml -*- manifest : version : 1.0 automations : # Assign special teams to review sensitive files. # This requires the `sensitive` custom expression found at the bottom of this file. review_sensitive_files : # For all files listed in the sensitive custom expression. if : - {{ files | match ( list = sensitive_files ) | some }} run : # Add reviewers from the dev-leads team, and require two approvals # Modify `my-organization/security` to match your organization. - action : add-reviewers@v1 args : reviewers : [ my-organization/security ] - action : set-required-approvals@v1 args : approvals : 2 - action : add-comment@v1 args : comment : | This PR affects one or more sensitive files and requires review from the security team. # The `sensitive_file_review` automation requires this custom expression. # Modify this list to suit your security needs. sensitive_files : - src/app/auth/ - src/app/routing/ - src/app/resources/ Download this example as a CM file.","title":"Review Sensitive Files"},{"location":"examples/#approve-safe-changes","text":"Automatically approve documentation, formatting, and test changes. More details here. Approve Safe Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : safe_changes : # Triggered for any changes that only affect formatting, documentation, tests, or images if : - {{ is .formatting or is .docs or is .tests or is .image }} # Apply a safe change label, approve the PR and explain why in a comment. run : - action : add-label@v1 args : label : 'safe-change' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR is considered a safe change and has been automatically approved. # These custom expressions are used in the safe_changes automation is : formatting : {{ source.diff.files | isFormattingChange }} docs : {{ files | allDocs }} tests : {{ files | allTests }} image : {{ files | allImages }} Download this example as a CM file.","title":"Approve Safe Changes"},{"location":"examples/#provide-estimated-time-to-review","text":"Label all PRs with an estimated number of minutes it would take someone to review. More details here. Provide Estimated Time to Review # -*- mode: yaml -*- manifest : version : 1.0 automations : estimated_time_to_review : if : - true run : - action : add-label@v1 args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} calc : etr : {{ branch | estimatedReviewTime }} Download this example as a CM file.","title":"Provide Estimated Time to Review"},{"location":"examples/#label-missing-jira-info","text":"Label PRs that don't reference a Jira ticket in the title or description. This uses regex to detect Jira ticket formats in the title (e.g. ABC-1234), and URLs to Jira tickets in the description. More details here. Label Missing Jira Info # -*- mode: yaml -*- manifest : version : 1.0 automations : label_missing_jira_info : # Triggered for PRs that don't have either a Jira ticket number in the title, # or a link to a Jira ticket in the PR description. if : - {{ not ( has.jira_ticket_in_title or has.jira_ticket_in_desc ) }} run : - action : add-label@v1 args : label : \"missing-jira\" color : 'F6443B' has : jira_ticket_in_title : {{ pr.title | includes ( regex = r / ^\\ [ ?\\ w { 3 , 4 }- \\ d { 1 , 6 } \\ ] ? ( \\ s | -| _ ) . { 1 ,} $ /) }} jira_ticket_in_desc : {{ pr.description | includes ( regex = r / atlassian.net \\ / browse \\ / \\ w { 1 ,}- \\ d { 3 , 4 }/) }} Download this example as a CM file.","title":"Label Missing Jira Info"},{"location":"examples/#more-examples","text":"Check out the gitStream automation library. Click here to find a more extensive list of automation examples.","title":"More examples"},{"location":"execution-model/","text":"Execution Model gitStream is triggered on new pull requests (PRs) for repositories that have gitStream installed. Upon triggering, gitStream collects context variables and evaluates the automation rules to determine which automation rules are relevant. Organization level rules and repository rules When a central cm repository is set with the CI/CD runner, the events for PRs from all installed repositories shall be evaluated in the cm repository pipeline, taking into account the organization level rules and the PR repository rules. Triggering events By default, gitStream evaluates any new commit that is pushed to the PR, triggering automation evaluation. Additionally, if any of the automation rules reference the pr context, gitStream shall trigger and will initiate automation rules evaluation even where there are changes to the PR title, descriptions, or labels. This allows for greater flexibility in the automation process, ensuring that the relevant automation rules are evaluated and triggered when necessary. The execution model ensures that the automation process is streamlined, efficient, and effective.","title":"Execution"},{"location":"execution-model/#execution-model","text":"gitStream is triggered on new pull requests (PRs) for repositories that have gitStream installed. Upon triggering, gitStream collects context variables and evaluates the automation rules to determine which automation rules are relevant.","title":"Execution Model"},{"location":"execution-model/#organization-level-rules-and-repository-rules","text":"When a central cm repository is set with the CI/CD runner, the events for PRs from all installed repositories shall be evaluated in the cm repository pipeline, taking into account the organization level rules and the PR repository rules.","title":"Organization level rules and repository rules"},{"location":"execution-model/#triggering-events","text":"By default, gitStream evaluates any new commit that is pushed to the PR, triggering automation evaluation. Additionally, if any of the automation rules reference the pr context, gitStream shall trigger and will initiate automation rules evaluation even where there are changes to the PR title, descriptions, or labels. This allows for greater flexibility in the automation process, ensuring that the relevant automation rules are evaluated and triggered when necessary. The execution model ensures that the automation process is streamlined, efficient, and effective.","title":"Triggering events"},{"location":"faq/","text":"FAQ What permissions needed? In your repo permissions, make sure GitHub actions are permitted: Go to Repo's settings > Actions > General > Actions permissions Choose which repositories are permitted to use GitHub Actions. [x] Allow all actions and reusable workflows Does gitStream services have access to my code? Like any other CI/CD automation, the source code is being scanned in the repo and is not shared with any external services. Only metadata that relates and affects the workflow is shared to allow rule based automation on the repo. Why does gitStream require permission to write code? In order to support automations that either Approve or Merge PRs, GitHub API requires code write scope. What repos are supported? Any repo in GitHub is supported. More Git providers are planned soon. Custom filter functions Coming soon. Is there .cm syntax highlighting? The .cm file use YAML with JINJA2, in order for your favorite editor to choose automatically the right syntax, you can use modelines. Add the following line to the top of the .cm file (the default has it already): # -*- mode: yaml -*- Get a plug-in that enable modelines, popular ones are: VS Code: Modelines Sublime Text: Emacs-like Sublime Modeline Vim Modeline magic I have an issue I can seem to solve, what should I do? Go to our issues page and check if there are any similar issues already reported, if not create a new issue with all the details so we can take a look. Found a bug? Create a new item in the project's issues","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#what-permissions-needed","text":"In your repo permissions, make sure GitHub actions are permitted: Go to Repo's settings > Actions > General > Actions permissions Choose which repositories are permitted to use GitHub Actions. [x] Allow all actions and reusable workflows","title":"What permissions needed?"},{"location":"faq/#does-gitstream-services-have-access-to-my-code","text":"Like any other CI/CD automation, the source code is being scanned in the repo and is not shared with any external services. Only metadata that relates and affects the workflow is shared to allow rule based automation on the repo.","title":"Does gitStream services have access to my code?"},{"location":"faq/#why-does-gitstream-require-permission-to-write-code","text":"In order to support automations that either Approve or Merge PRs, GitHub API requires code write scope.","title":"Why does gitStream require permission to write code?"},{"location":"faq/#what-repos-are-supported","text":"Any repo in GitHub is supported. More Git providers are planned soon.","title":"What repos are supported?"},{"location":"faq/#custom-filter-functions","text":"Coming soon.","title":"Custom filter functions"},{"location":"faq/#is-there-cm-syntax-highlighting","text":"The .cm file use YAML with JINJA2, in order for your favorite editor to choose automatically the right syntax, you can use modelines. Add the following line to the top of the .cm file (the default has it already): # -*- mode: yaml -*- Get a plug-in that enable modelines, popular ones are: VS Code: Modelines Sublime Text: Emacs-like Sublime Modeline Vim Modeline magic","title":"Is there .cm syntax highlighting?"},{"location":"faq/#i-have-an-issue-i-can-seem-to-solve-what-should-i-do","text":"Go to our issues page and check if there are any similar issues already reported, if not create a new issue with all the details so we can take a look. Found a bug? Create a new item in the project's issues","title":"I have an issue I can seem to solve, what should I do?"},{"location":"filter-functions/","text":"Filter functions Filters can change the look and format of the source data, or even generate new data derived from the input values. What's important is that the original data is replaced by the result of transformations, and that's what ends up in rendered templates. Note Items marked with are under development and are not available yet. Overview The following functions are supported in addition to the built-in functions provided by Nunjucks . Low level functions Function Input Args Output every Checks whether all element in the list are true [Bool] - Bool filter Reduce list of items into a list of same items that match the specified term [String] [Object] regex , term , list , attr [String] [Object] includes Check if substring match String regex , term , list Bool map Maps each object in a list into their specified attribute value [Object] attr [Object] match Maps list of items into a list of booleans that match the specified term [String] [Object] regex , term , list attr [Bool] nope Checks whether all element in the list are false [Bool] - Bool reject Inverse of filter , the result list contains non-matching items [String] [Object] regex , term , list , attr [String] [Object] some Checks whether at least one element in the list is true [Bool] - Bool High level functions Function Input Args Output allDocs Checks the list includes only documents files - Bool allImages Checks the list includes only images files - Bool allTests Checks the list includes only tests files - Bool codeExperts Get list of contributors based on expert reviewer model results repo gt , lt [String] estimatedReviewTime Estimated review time in minutes branch - Integer extensions Lists all the unique file extensions [String] - [String] extractSonarFindings Get an object with a summary of the findings found by the SonarCloud scan pr - Object extractJitFindings Get an object with a summary of the findings found by the Jit scan pr - Object explainCodeExperts Short markdown text explaining codeExperts results repo gt , lt [String] explainRankByGitBlame Short markdown text explaining rankByGitBlame results repo gt , lt [String] isFirstCommit Checks if its the author first commit in the repo repo.contributors String Bool isFormattingChange Checks that only formatting changed [ FileDiff ] - Bool mapToEnum return the enum value matches to the input key String Enum object Object matchDiffLines Match every line in diff [ FileDiff ] regex , ignoreWhiteSpaces [Bool] rankByGitActivity Get list of contributors based on git-commit activity repo gt , lt [String] rankByGitBlame Get list of contributors based on git-blame results repo gt , lt [String] Named arguments Some functions support named arguments, many of these repeat in different functions. term - a single string, used as a substring to match with the matched item. list - a list of strings, trying to match any of the listed substrings with the matched item. regex - a single string, used as a regular expression with the matched item. A regular expression can be created just like JavaScript, but needs to be prefixed with r, for example, r/^foo.*/g , for more info see Nunjucks . globs - a key to an element in the .cm that holds a list of strings, used as glob pattern test on the matched item. For more info, see Wikipedia . attr - a key in the element to use when doing the requested operation. For example, the following expressions provide an identical result: - {{ 'something' | includes ( regex = r / ^ some . */) }} - {{ 'something' | includes ( term = 'some' ) }} - {{ 'something' | includes ( list =[ 'some' ]) }} Reference every Checks whether all element in the list are true . In case the list of elements is empty, it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when all list items are true For example, check that all changes are in either 'src' or 'dest' directories: {{ files | match ( list =[ 'src' , 'dest' ]) | every }} filter Creates a shallow copy of a portion of a given list, filtered down to just the elements that match the given term. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input [String] [Object] The list of strings to match, or list of objects if attr is used term regex list Input (either) String String [String] Search term to match with the input items attr Input (optional) String match a named attribute in the input object - Output [String] [Object] The list with only the matching items For example, check if all changes to JavaScript files are in tests directory: {{ files | filter ( regex = r / \\ .js $ /) | match ( regex = r / tests \\ //) | every }} For example, check if all changes to JavaScript files are formatting: {{ source.diff.files | filter ( attr = 'new_file' , regex = r / \\ .js $ /) | isFormattingChange }} includes Determines whether a string includes a certain substring. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input String The list of strings to match term regex list Input (either) String String [String] Substring term to match - Output Bool true if search terms matches Check string matches either of the terms: {{ 'something' | includes ( list =[ 'any' , 'thing' ]) }} map Creates a new list populated with the values of the selected attribute of every element in the input list. Argument Usage Type Description - Input [Object] The list of objects to map, see context for valid inputs attr Input String Object attribute to select - Output [Object] List of the selected object attributes For example, the source.diff.files context holds a list of FileDiff , each has new_file attribute. You can create a list of all the new file names by mapping to the new_file attribute and then check if there are changes to any handler.js file: {{ source.diff.files | map ( attr = 'new_file' ) | match ( term = 'handler.js' ) | some }} match Return true for each element in the list that match the search term. Argument Usage Type Description - Input [String] [Object] The list of strings or if attr used the list of objects term regex list Input (either) String String [String] Search term to match attr Input String match a named attribute in the input object - Output [Bool] true for every matching item For example, to check if all code changes are in the tests directory: {{ files | match ( regex = r / tests \\ //) | every }} For example, to check if there are code changes with specific function call: {{ source.diff.files | match ( attr = 'diff' , term = 'myFunction' ) | some }} nope The inverse of every , checks whether all elements in the list are false . In case the list of elements is empty, it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when all list items are false For example, check that no changes in either 'src' or 'dest' directories: {{ files | match ( list =[ 'src' , 'dest' ]) | nope }} reject Creates a shallow copy of a portion of a given list, filtered down to just the elements that do not match the given term. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input [String] [Object] The list of strings to match, or list of objects if attr is used term regex list Input (either) String String [String] Search term to match with the input items attr Input (optional) String match a named attribute in the input object - Output [String] [Object] The list with only the non-matching items For example, check if all changes, but JavaScript files are in tests directory: {{ files | reject ( regex = r / \\ .js $ /) | match ( regex = r / tests \\ // ' ) | every }} For example, check if all changes except for config.json files are formatting: {{ source.diff.files | reject ( attr = 'new_file' , regex = r / config \\ .json $ /) | isFormattingChange }} some Checks whether any element in the list is true . In case the list of elements is empty it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when any of the items is true {{ files | match ( list =[ 'src' , 'dest' ]) | some }} allDocs Return true if the input list includes only documents based on file extensions. Doc files extensions are: md , mkdown , txt , rst , adoc , except for requirements.txt . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file extensions are of docs {{ files | allDocs }} In case you want to exclude more files, like all txt under the requirements directory, add another check: {{ ( files | allDocs ) and ( files | match ( regex = r / requirements \\ / . * \\ .txt $ /) | nope ) }} allImages Return true if the input list includes only images based on file extensions. Image file extensions are: svg , png , gif . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file extensions are of images {{ files | allImages }} allTests Return true if the input list includes only tests based on the file's path and name. To identify as test the file must include the word test or spec in its name or path, it is checked using this regex: [^a-zA-Z0-9](spec|test|tests)[^a-zA-Z0-9] . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file tests are based on name and path {{ files | allTests }} codeExperts When requesting a review for a pull request, it's important to select a reviewer who has a deep understanding of the relevant code area, the domain problem, and the framework being used. This ensures that the reviewer can provide specific and informed feedback, rather than general comments that may not take into account the context in which the issue was solved. The filter provides the list of most qualified contributors based on git-blame and git-commit results to determine who has been most active in the relevant code area, and then combines this information into a score between 0 and 100. The commit activity is scored higher for recent commits, which ensures that those who are actively contributing to the codebase are given higher priority as potential reviewers. The result will be limited to 2 users and shall not include the PR author. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines. Note The codeExperts filter function calls gitStream app API with the repo context to calculate the estimated review time value. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] Up to 2 users, sorted by best match first (it won't include the PR author) For example: automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} estimatedReviewTime Returns the estimated review time in minutes based on statistical model. The model uses the amount of additions and deletions statistics for each file type with additional information about the commits and base branch. Note The estimatedReviewTime filter function calls gitStream app API with the branch context to calculate the estimated review time value. The following files are excluded when calculating this value: Argument Usage Type Description - Input branch Branch meta data - Output Integer the estimated time for review in minutes {{ branch | estimatedReviewTime }} The following files are automatically excluded from the estimated review time calculation. File type Filter type Values Data Extension ini csv xls xlsx xlr doc docx txt pps ppt pptx dot dotx log tar rtf dat ipynb po profile object obj dxf twb bcsymbolmap tfstate pdf rbi pem crt svg png jpeg jpg ttf Data Regex .*dist/.*\\.js$ .*public/assets/.*\\.js$ Lock Regex .*package-lock|packages\\.lock|package)\\.json$ Lock File yarn.lock gemfile.lock podfile.lock cargo.lock composer.lock pipfile.lock gopkg.lock Lock Regex .*gradle\\.lockfile$ .*lock\\.sbt$ Pipeline Regex .*ci\\.yml$ Tip You can also filter more files, using config.ignore_files . extensions Expects files and provide a list of all unique file extensions. Argument Usage Type Description - Input files The list of changed files with their path - Output [String] List of all unique file extensions For example, check that only one file type was changed: {{ files | extensions | length == 1 }} extractJitFindings Get an object with a summary of the findings found by Jit scan. This filter is relevant only for repos that use Jit to scan PRs The pr context includes all the reviews in the pull request, including the reviews written by the Jit bot, along with all the comments ( conversations ) to the review. This filter reads and parses the reviews with Jit's findings, making them available for use inside the .cm file automations. The output is an object of the following format: { \"vulnerabilities\" : [{ \"security_control\" : 's tr i n g' , \"type\" : 's tr i n g' , \"description\" : 's tr i n g' , \"severity\" : 's tr i n g' , \"summary\" : 's tr i n g' }], \"metrics\" : { \"HIGH\" : nu mber , \"MEDIUM\" : nu mber , \"LOW\" : nu mber , \"INFO\" : nu mber } } Argument Usage Type Description - Input pr The pr context variable - Output Object The object contains the summary of Jit's scan Example of the filter output { \"vulnerabilities\" : [ { \"security_control\" : \"Static Code Analysis Js\" , \"type\" : \"Codsec.Javascriptnosql-Injection.Nosql-Injection\" , \"description\" : \"Putting request data into a mongo query can leadto a NoSQL Injection. Be sure to properly sanitize thedata if you absolutely must pass request data into a query.\" , \"severity\" : \"HIGH\" , \"summary\" : \"Jit Bot commands and options (e.g., ignore issue)\" }, { \"security_control\" : \"Secret Detection\" , \"type\" : \"Private-Key\" , \"description\" : \"Private Key\" , \"severity\" : \"HIGH\" , \"summary\" : \"Jit Bot commands and options (e.g., ignore issue)\" } ], \"metrics\" : { \"HIGH\" : 2 , \"MEDIUM\" : 0 , \"LOW\" : 0 , \"INFO\" : 0 } } Assign the output to a variable jit : {{ pr | extractJitFindings }} Add a label if Jit detected secrets in the PR automations : # Add Bugs label if : - {{ jit.bugs.rating != 'A' }} run : - action : add-label@v1 args : label : \"\ud83e\udd2b PR with secrets\" extractSonarFindings Get an object with a summary of the findings found by the SonarCloud scan. This filter is relevant only for repos that use SonarCloud to scan PRs The pr context includes all the comments added to the pull request, including the comment written by the SonarCloud bot that holds a summary of its scan. This filter reads and parses the comment with SonarCloud's scan summary and makes them available to use inside the .cm file automations. The output is an object of the following format: { \"bugs\" : { \"count\" : nu mber , \"rating\" : 's tr i n g' //('A'-'E') }, \"code_smells\" : { \"count\" : nu mber , \"rating\" : 's tr i n g' //('A'-'E') }, \"vulnerabilities\" : { \"count\" : nu mber , \"rating\" : 's tr i n g' //('A'-'E') }, \"security_hotspots\" : { \"count\" : nu mber , \"rating\" : 's tr i n g' //('A'-'E') }, \"duplications\" : nu mber , \"coverage\" : nu mber } Argument Usage Type Description - Input pr The pr context variable - Output Object The object contains the summary of SonCloud's scan Example of the filter output { \"bugs\" : { \"count\" : 1 , \"rating\" : 'B' }, \"code_smells\" : { \"count\" : 2 , \"rating\" : 'B' }, \"vulnerabilities\" : { \"count\" : 2 , \"rating\" : 'E' }, \"security_hotspots\" : { \"count\" : 0 , \"rating\" : 'A' }, \"duplications\" : 3 , \"coverage\" : 70 } Assign the output to a variable sonar : {{ pr | extractSonarFindings }} Add a label with the number of bugs if the bugs rating is other than 'A', and use mapToEnum to set its color automations : # Add Bugs label show_bugs_count : if : - {{ sonar.bugs.count > 0 }} run : - action : add-label@v1 args : label : '\ud83d\udc1e x {{ sonar.bugs.count }} Bugs' color : {{ sonar.bugs.rating | mapToEnum ( enum = colors ) }} colors : A : '05AA02' B : 'B6D146' C : 'EABE05' D : 'DF8339' E : 'D4343F' explainCodeExperts This filter helps to explain the results of codeExperts , the output is in Markdown format that can be used in a PR comment. The explainCodeExperts filter function calls gitStream app API with the repo context to calculate the estimated review time value. Note If you use this function to post a comment to a GitHub PR conversation, gitStream will update the comment for every new commit. You may need to refresh your page to clean up the older comment versions. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining codeExperts results in markdown format For example: automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Note the comment starts with | and a new-line as explainCodeExperts generates a multiline comment. explainRankByGitBlame This filter helps to explain the results of rankByGitBlame , the output is in Markdown format that can be used in a PR comment. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. Git users that could not be automatically mapped are marked with * . To map these users, you can add user_mapping see instructions here . Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining rankByGitBlame results in markdown format Note Each contributor's result is rounded down to the nearest integer, so the total may add up to less than 100%. For example: automations : the_right_reviewer : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | rankByGitBlame ( gt = 50 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainRankByGitBlame ( gt = 50 ) }} Note the comment starts with | and a new-line as explainRankByGitBlame generates a multiline comment. isFirstCommit Return true if it's the author first commit in the repo. Argument Usage Type Description - Input repo.contributors List of contributors in the repo - Input String The contributor name - Output Bool true if its the first commit of the selected contributor if : - {{ repo.contributors | isFirstCommit ( branch.author ) }} run : - action : add-comment@v1 args : comment : Welcome {{ branch.author }} ! isFormattingChange Return true if all file diffs are validated as formatting changes. This filter function works for JavaScript, TypeScript, Python, JSON, YAML and HTML. gitStream determines formatting changes by minifying the source code for the incoming changes and the existing code and comparing them. If they are identical, this filter function returns true . If any unsupported languages are contained in the PR, gitStream will return false . Argument Usage Type Description - Input source.diff.files List of file diffs - Output Bool true if the all code changes are non functional {{ source.diff.files | isFormattingChange }} mapToEnum Get the enum value matches to the input key Argument Usage Type Description - Input String The key name enum Input Enum Object The enum object to which the input string should be matched - Output Object The value of the input key in the input enum object For example, set a label color according to names in the enum: automations : label_color : if : - true run : - action : add-label@v1 args : label : 'Blue label' color : {{ \"blue\" | mapToEnum ( enum = colors ) }} colors : red : 'FF0000' green : '00FF00' blue : '0000FF' yellow : 'FFFF00' matchDiffLines Checks diff for matching lines. Argument Usage Type Description - Input [Object] The list of objects regex Input String Regex term to match with the input items, use \\\\ for \\ ignoreWhiteSpaces Input Bool false by default, match a named attribute in the input object caseSensitive Input Bool true by default, ignore case when matching terms - Output [Bool] true for every matching object For example, to check if all the changes are of adding prints and ignore white spaces: {{ source.diff.files | matchDiffLines ( regex = r / ^\\ + . * console \\ .log /, ignoreWhiteSpaces = true ) | every }} rankByGitActivity Get list of contributors based on git-commit activity. The repo context includes all the changed files, for each file it includes each contributor number of lines changed every week over the last 52 weeks, based on git-commit . These functions compare each contributor changes per week and yield an average percentage of contribution for any given file. For example, in a certain week a file had 500 line changed, 200 by a first user, while 3 other users changed 100 lines each. So the score for the first user in that week will be 40 (200/500 in %). The function then average the score for each user for the selected time period. Then you can use the thresholds to get the right reviewer. Argument Usage Type Description - Input repo The repo context variable weeks Input Integer The number of last weeks to include lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison Check if the branch author is a rookie active_coders : {{ repo | rankByGitActivity ( gt = 50 , weeks = 12 ) }} rankByGitBlame Get list of contributors based on git-blame results The repo context includes all the changed files, for each file it includes the contributors' percentage of lines in the file, based on git-blame . This function sums all these percentages per user and yield an average percentage of contribution. Then you can use the thresholds to get the right reviewer. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison, sorted by rank - first has highest score Example of the filter output, note the output are GitHub users in the example: [ \"PopeyeUser\" , \"olive_user\" , \"BRUTUS_USER\" ] Get the most significant contributors for the PR files: contributors : {{ repo | rankByGitBlame ( gt = 30 ) }} Check if the branch author is a rookie is_rookie : {{ repo | rankByGitBlame ( lt = 15 ) | match ( term = branch.author ) | some }}","title":"Filter functions"},{"location":"filter-functions/#filter-functions","text":"Filters can change the look and format of the source data, or even generate new data derived from the input values. What's important is that the original data is replaced by the result of transformations, and that's what ends up in rendered templates. Note Items marked with are under development and are not available yet.","title":"Filter functions"},{"location":"filter-functions/#overview","text":"The following functions are supported in addition to the built-in functions provided by Nunjucks .","title":"Overview"},{"location":"filter-functions/#low-level-functions","text":"Function Input Args Output every Checks whether all element in the list are true [Bool] - Bool filter Reduce list of items into a list of same items that match the specified term [String] [Object] regex , term , list , attr [String] [Object] includes Check if substring match String regex , term , list Bool map Maps each object in a list into their specified attribute value [Object] attr [Object] match Maps list of items into a list of booleans that match the specified term [String] [Object] regex , term , list attr [Bool] nope Checks whether all element in the list are false [Bool] - Bool reject Inverse of filter , the result list contains non-matching items [String] [Object] regex , term , list , attr [String] [Object] some Checks whether at least one element in the list is true [Bool] - Bool","title":"Low level functions"},{"location":"filter-functions/#high-level-functions","text":"Function Input Args Output allDocs Checks the list includes only documents files - Bool allImages Checks the list includes only images files - Bool allTests Checks the list includes only tests files - Bool codeExperts Get list of contributors based on expert reviewer model results repo gt , lt [String] estimatedReviewTime Estimated review time in minutes branch - Integer extensions Lists all the unique file extensions [String] - [String] extractSonarFindings Get an object with a summary of the findings found by the SonarCloud scan pr - Object extractJitFindings Get an object with a summary of the findings found by the Jit scan pr - Object explainCodeExperts Short markdown text explaining codeExperts results repo gt , lt [String] explainRankByGitBlame Short markdown text explaining rankByGitBlame results repo gt , lt [String] isFirstCommit Checks if its the author first commit in the repo repo.contributors String Bool isFormattingChange Checks that only formatting changed [ FileDiff ] - Bool mapToEnum return the enum value matches to the input key String Enum object Object matchDiffLines Match every line in diff [ FileDiff ] regex , ignoreWhiteSpaces [Bool] rankByGitActivity Get list of contributors based on git-commit activity repo gt , lt [String] rankByGitBlame Get list of contributors based on git-blame results repo gt , lt [String]","title":"High level functions"},{"location":"filter-functions/#named-arguments","text":"Some functions support named arguments, many of these repeat in different functions. term - a single string, used as a substring to match with the matched item. list - a list of strings, trying to match any of the listed substrings with the matched item. regex - a single string, used as a regular expression with the matched item. A regular expression can be created just like JavaScript, but needs to be prefixed with r, for example, r/^foo.*/g , for more info see Nunjucks . globs - a key to an element in the .cm that holds a list of strings, used as glob pattern test on the matched item. For more info, see Wikipedia . attr - a key in the element to use when doing the requested operation. For example, the following expressions provide an identical result: - {{ 'something' | includes ( regex = r / ^ some . */) }} - {{ 'something' | includes ( term = 'some' ) }} - {{ 'something' | includes ( list =[ 'some' ]) }}","title":"Named arguments"},{"location":"filter-functions/#reference","text":"","title":"Reference"},{"location":"filter-functions/#every","text":"Checks whether all element in the list are true . In case the list of elements is empty, it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when all list items are true For example, check that all changes are in either 'src' or 'dest' directories: {{ files | match ( list =[ 'src' , 'dest' ]) | every }}","title":"every"},{"location":"filter-functions/#filter","text":"Creates a shallow copy of a portion of a given list, filtered down to just the elements that match the given term. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input [String] [Object] The list of strings to match, or list of objects if attr is used term regex list Input (either) String String [String] Search term to match with the input items attr Input (optional) String match a named attribute in the input object - Output [String] [Object] The list with only the matching items For example, check if all changes to JavaScript files are in tests directory: {{ files | filter ( regex = r / \\ .js $ /) | match ( regex = r / tests \\ //) | every }} For example, check if all changes to JavaScript files are formatting: {{ source.diff.files | filter ( attr = 'new_file' , regex = r / \\ .js $ /) | isFormattingChange }}","title":"filter"},{"location":"filter-functions/#includes","text":"Determines whether a string includes a certain substring. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input String The list of strings to match term regex list Input (either) String String [String] Substring term to match - Output Bool true if search terms matches Check string matches either of the terms: {{ 'something' | includes ( list =[ 'any' , 'thing' ]) }}","title":"includes"},{"location":"filter-functions/#map","text":"Creates a new list populated with the values of the selected attribute of every element in the input list. Argument Usage Type Description - Input [Object] The list of objects to map, see context for valid inputs attr Input String Object attribute to select - Output [Object] List of the selected object attributes For example, the source.diff.files context holds a list of FileDiff , each has new_file attribute. You can create a list of all the new file names by mapping to the new_file attribute and then check if there are changes to any handler.js file: {{ source.diff.files | map ( attr = 'new_file' ) | match ( term = 'handler.js' ) | some }}","title":"map"},{"location":"filter-functions/#match","text":"Return true for each element in the list that match the search term. Argument Usage Type Description - Input [String] [Object] The list of strings or if attr used the list of objects term regex list Input (either) String String [String] Search term to match attr Input String match a named attribute in the input object - Output [Bool] true for every matching item For example, to check if all code changes are in the tests directory: {{ files | match ( regex = r / tests \\ //) | every }} For example, to check if there are code changes with specific function call: {{ source.diff.files | match ( attr = 'diff' , term = 'myFunction' ) | some }}","title":"match"},{"location":"filter-functions/#nope","text":"The inverse of every , checks whether all elements in the list are false . In case the list of elements is empty, it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when all list items are false For example, check that no changes in either 'src' or 'dest' directories: {{ files | match ( list =[ 'src' , 'dest' ]) | nope }}","title":"nope"},{"location":"filter-functions/#reject","text":"Creates a shallow copy of a portion of a given list, filtered down to just the elements that do not match the given term. You can use either a single term, regex, or a list of terms to match with. Argument Usage Type Description - Input [String] [Object] The list of strings to match, or list of objects if attr is used term regex list Input (either) String String [String] Search term to match with the input items attr Input (optional) String match a named attribute in the input object - Output [String] [Object] The list with only the non-matching items For example, check if all changes, but JavaScript files are in tests directory: {{ files | reject ( regex = r / \\ .js $ /) | match ( regex = r / tests \\ // ' ) | every }} For example, check if all changes except for config.json files are formatting: {{ source.diff.files | reject ( attr = 'new_file' , regex = r / config \\ .json $ /) | isFormattingChange }}","title":"reject"},{"location":"filter-functions/#some","text":"Checks whether any element in the list is true . In case the list of elements is empty it will return false . Argument Usage Type Description - Input [Bool] List of booleans - Output Bool Returns true when any of the items is true {{ files | match ( list =[ 'src' , 'dest' ]) | some }}","title":"some"},{"location":"filter-functions/#alldocs","text":"Return true if the input list includes only documents based on file extensions. Doc files extensions are: md , mkdown , txt , rst , adoc , except for requirements.txt . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file extensions are of docs {{ files | allDocs }} In case you want to exclude more files, like all txt under the requirements directory, add another check: {{ ( files | allDocs ) and ( files | match ( regex = r / requirements \\ / . * \\ .txt $ /) | nope ) }}","title":"allDocs"},{"location":"filter-functions/#allimages","text":"Return true if the input list includes only images based on file extensions. Image file extensions are: svg , png , gif . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file extensions are of images {{ files | allImages }}","title":"allImages"},{"location":"filter-functions/#alltests","text":"Return true if the input list includes only tests based on the file's path and name. To identify as test the file must include the word test or spec in its name or path, it is checked using this regex: [^a-zA-Z0-9](spec|test|tests)[^a-zA-Z0-9] . Argument Usage Type Description - Input files The list of changed files with their path - Output Bool true if all file tests are based on name and path {{ files | allTests }}","title":"allTests"},{"location":"filter-functions/#codeexperts","text":"When requesting a review for a pull request, it's important to select a reviewer who has a deep understanding of the relevant code area, the domain problem, and the framework being used. This ensures that the reviewer can provide specific and informed feedback, rather than general comments that may not take into account the context in which the issue was solved. The filter provides the list of most qualified contributors based on git-blame and git-commit results to determine who has been most active in the relevant code area, and then combines this information into a score between 0 and 100. The commit activity is scored higher for recent commits, which ensures that those who are actively contributing to the codebase are given higher priority as potential reviewers. The result will be limited to 2 users and shall not include the PR author. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines. Note The codeExperts filter function calls gitStream app API with the repo context to calculate the estimated review time value. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] Up to 2 users, sorted by best match first (it won't include the PR author) For example: automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }}","title":"codeExperts"},{"location":"filter-functions/#estimatedreviewtime","text":"Returns the estimated review time in minutes based on statistical model. The model uses the amount of additions and deletions statistics for each file type with additional information about the commits and base branch. Note The estimatedReviewTime filter function calls gitStream app API with the branch context to calculate the estimated review time value. The following files are excluded when calculating this value: Argument Usage Type Description - Input branch Branch meta data - Output Integer the estimated time for review in minutes {{ branch | estimatedReviewTime }} The following files are automatically excluded from the estimated review time calculation. File type Filter type Values Data Extension ini csv xls xlsx xlr doc docx txt pps ppt pptx dot dotx log tar rtf dat ipynb po profile object obj dxf twb bcsymbolmap tfstate pdf rbi pem crt svg png jpeg jpg ttf Data Regex .*dist/.*\\.js$ .*public/assets/.*\\.js$ Lock Regex .*package-lock|packages\\.lock|package)\\.json$ Lock File yarn.lock gemfile.lock podfile.lock cargo.lock composer.lock pipfile.lock gopkg.lock Lock Regex .*gradle\\.lockfile$ .*lock\\.sbt$ Pipeline Regex .*ci\\.yml$ Tip You can also filter more files, using config.ignore_files .","title":"estimatedReviewTime"},{"location":"filter-functions/#extensions","text":"Expects files and provide a list of all unique file extensions. Argument Usage Type Description - Input files The list of changed files with their path - Output [String] List of all unique file extensions For example, check that only one file type was changed: {{ files | extensions | length == 1 }}","title":"extensions"},{"location":"filter-functions/#extractjitfindings","text":"Get an object with a summary of the findings found by Jit scan. This filter is relevant only for repos that use Jit to scan PRs The pr context includes all the reviews in the pull request, including the reviews written by the Jit bot, along with all the comments ( conversations ) to the review. This filter reads and parses the reviews with Jit's findings, making them available for use inside the .cm file automations. The output is an object of the following format: { \"vulnerabilities\" : [{ \"security_control\" : 's tr i n g' , \"type\" : 's tr i n g' , \"description\" : 's tr i n g' , \"severity\" : 's tr i n g' , \"summary\" : 's tr i n g' }], \"metrics\" : { \"HIGH\" : nu mber , \"MEDIUM\" : nu mber , \"LOW\" : nu mber , \"INFO\" : nu mber } } Argument Usage Type Description - Input pr The pr context variable - Output Object The object contains the summary of Jit's scan Example of the filter output { \"vulnerabilities\" : [ { \"security_control\" : \"Static Code Analysis Js\" , \"type\" : \"Codsec.Javascriptnosql-Injection.Nosql-Injection\" , \"description\" : \"Putting request data into a mongo query can leadto a NoSQL Injection. Be sure to properly sanitize thedata if you absolutely must pass request data into a query.\" , \"severity\" : \"HIGH\" , \"summary\" : \"Jit Bot commands and options (e.g., ignore issue)\" }, { \"security_control\" : \"Secret Detection\" , \"type\" : \"Private-Key\" , \"description\" : \"Private Key\" , \"severity\" : \"HIGH\" , \"summary\" : \"Jit Bot commands and options (e.g., ignore issue)\" } ], \"metrics\" : { \"HIGH\" : 2 , \"MEDIUM\" : 0 , \"LOW\" : 0 , \"INFO\" : 0 } } Assign the output to a variable jit : {{ pr | extractJitFindings }} Add a label if Jit detected secrets in the PR automations : # Add Bugs label if : - {{ jit.bugs.rating != 'A' }} run : - action : add-label@v1 args : label : \"\ud83e\udd2b PR with secrets\"","title":"extractJitFindings"},{"location":"filter-functions/#extractsonarfindings","text":"Get an object with a summary of the findings found by the SonarCloud scan. This filter is relevant only for repos that use SonarCloud to scan PRs The pr context includes all the comments added to the pull request, including the comment written by the SonarCloud bot that holds a summary of its scan. This filter reads and parses the comment with SonarCloud's scan summary and makes them available to use inside the .cm file automations. The output is an object of the following format: { \"bugs\" : { \"count\" : nu mber , \"rating\" : 's tr i n g' //('A'-'E') }, \"code_smells\" : { \"count\" : nu mber , \"rating\" : 's tr i n g' //('A'-'E') }, \"vulnerabilities\" : { \"count\" : nu mber , \"rating\" : 's tr i n g' //('A'-'E') }, \"security_hotspots\" : { \"count\" : nu mber , \"rating\" : 's tr i n g' //('A'-'E') }, \"duplications\" : nu mber , \"coverage\" : nu mber } Argument Usage Type Description - Input pr The pr context variable - Output Object The object contains the summary of SonCloud's scan Example of the filter output { \"bugs\" : { \"count\" : 1 , \"rating\" : 'B' }, \"code_smells\" : { \"count\" : 2 , \"rating\" : 'B' }, \"vulnerabilities\" : { \"count\" : 2 , \"rating\" : 'E' }, \"security_hotspots\" : { \"count\" : 0 , \"rating\" : 'A' }, \"duplications\" : 3 , \"coverage\" : 70 } Assign the output to a variable sonar : {{ pr | extractSonarFindings }} Add a label with the number of bugs if the bugs rating is other than 'A', and use mapToEnum to set its color automations : # Add Bugs label show_bugs_count : if : - {{ sonar.bugs.count > 0 }} run : - action : add-label@v1 args : label : '\ud83d\udc1e x {{ sonar.bugs.count }} Bugs' color : {{ sonar.bugs.rating | mapToEnum ( enum = colors ) }} colors : A : '05AA02' B : 'B6D146' C : 'EABE05' D : 'DF8339' E : 'D4343F'","title":"extractSonarFindings"},{"location":"filter-functions/#explaincodeexperts","text":"This filter helps to explain the results of codeExperts , the output is in Markdown format that can be used in a PR comment. The explainCodeExperts filter function calls gitStream app API with the repo context to calculate the estimated review time value. Note If you use this function to post a comment to a GitHub PR conversation, gitStream will update the comment for every new commit. You may need to refresh your page to clean up the older comment versions. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining codeExperts results in markdown format For example: automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Note the comment starts with | and a new-line as explainCodeExperts generates a multiline comment.","title":"explainCodeExperts"},{"location":"filter-functions/#explainrankbygitblame","text":"This filter helps to explain the results of rankByGitBlame , the output is in Markdown format that can be used in a PR comment. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. Git users that could not be automatically mapped are marked with * . To map these users, you can add user_mapping see instructions here . Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output String Explaining rankByGitBlame results in markdown format Note Each contributor's result is rounded down to the nearest integer, so the total may add up to less than 100%. For example: automations : the_right_reviewer : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | rankByGitBlame ( gt = 50 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainRankByGitBlame ( gt = 50 ) }} Note the comment starts with | and a new-line as explainRankByGitBlame generates a multiline comment.","title":"explainRankByGitBlame"},{"location":"filter-functions/#isfirstcommit","text":"Return true if it's the author first commit in the repo. Argument Usage Type Description - Input repo.contributors List of contributors in the repo - Input String The contributor name - Output Bool true if its the first commit of the selected contributor if : - {{ repo.contributors | isFirstCommit ( branch.author ) }} run : - action : add-comment@v1 args : comment : Welcome {{ branch.author }} !","title":"isFirstCommit"},{"location":"filter-functions/#isformattingchange","text":"Return true if all file diffs are validated as formatting changes. This filter function works for JavaScript, TypeScript, Python, JSON, YAML and HTML. gitStream determines formatting changes by minifying the source code for the incoming changes and the existing code and comparing them. If they are identical, this filter function returns true . If any unsupported languages are contained in the PR, gitStream will return false . Argument Usage Type Description - Input source.diff.files List of file diffs - Output Bool true if the all code changes are non functional {{ source.diff.files | isFormattingChange }}","title":"isFormattingChange"},{"location":"filter-functions/#maptoenum","text":"Get the enum value matches to the input key Argument Usage Type Description - Input String The key name enum Input Enum Object The enum object to which the input string should be matched - Output Object The value of the input key in the input enum object For example, set a label color according to names in the enum: automations : label_color : if : - true run : - action : add-label@v1 args : label : 'Blue label' color : {{ \"blue\" | mapToEnum ( enum = colors ) }} colors : red : 'FF0000' green : '00FF00' blue : '0000FF' yellow : 'FFFF00'","title":"mapToEnum"},{"location":"filter-functions/#matchdifflines","text":"Checks diff for matching lines. Argument Usage Type Description - Input [Object] The list of objects regex Input String Regex term to match with the input items, use \\\\ for \\ ignoreWhiteSpaces Input Bool false by default, match a named attribute in the input object caseSensitive Input Bool true by default, ignore case when matching terms - Output [Bool] true for every matching object For example, to check if all the changes are of adding prints and ignore white spaces: {{ source.diff.files | matchDiffLines ( regex = r / ^\\ + . * console \\ .log /, ignoreWhiteSpaces = true ) | every }}","title":"matchDiffLines"},{"location":"filter-functions/#rankbygitactivity","text":"Get list of contributors based on git-commit activity. The repo context includes all the changed files, for each file it includes each contributor number of lines changed every week over the last 52 weeks, based on git-commit . These functions compare each contributor changes per week and yield an average percentage of contribution for any given file. For example, in a certain week a file had 500 line changed, 200 by a first user, while 3 other users changed 100 lines each. So the score for the first user in that week will be 40 (200/500 in %). The function then average the score for each user for the selected time period. Then you can use the thresholds to get the right reviewer. Argument Usage Type Description - Input repo The repo context variable weeks Input Integer The number of last weeks to include lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison Check if the branch author is a rookie active_coders : {{ repo | rankByGitActivity ( gt = 50 , weeks = 12 ) }}","title":"rankByGitActivity"},{"location":"filter-functions/#rankbygitblame","text":"Get list of contributors based on git-blame results The repo context includes all the changed files, for each file it includes the contributors' percentage of lines in the file, based on git-blame . This function sums all these percentages per user and yield an average percentage of contribution. Then you can use the thresholds to get the right reviewer. The output lists the Git provider users, e.g., GitHub users, which are mapped from the Git users included in the git-blame output. When gitStream cannot map the Git user to a Git provider user it will be dropped from the output list, hence the list may contain less than 100% of the lines. Argument Usage Type Description - Input repo The repo context variable lt Input Integer Filter the user list, keeping those below the specified threshold gt Input Integer Filter the user list, keeping those above the specified threshold - Output [String] The list of users based on their code score comparison, sorted by rank - first has highest score Example of the filter output, note the output are GitHub users in the example: [ \"PopeyeUser\" , \"olive_user\" , \"BRUTUS_USER\" ] Get the most significant contributors for the PR files: contributors : {{ repo | rankByGitBlame ( gt = 30 ) }} Check if the branch author is a rookie is_rookie : {{ repo | rankByGitBlame ( lt = 15 ) | match ( term = branch.author ) | some }}","title":"rankByGitBlame"},{"location":"github-installation/","text":"How to Setup gitStream with GitHub Install gitStream Before you can complete the gitStream setup process, you need to install the gitStream app to your GitHub organization . Setup You can set up gitStream for a single repo or your entire GitHub organization. Select the tab below for the instructions you want. Single Repo GitHub Organization Single Repo Setup You must implement two main components for gitStream to function for a single GitHub repo. The first is a configuration file that defines the workflow automations to execute for the repo. The second is a GitHub actions configuration file that triggers gitStream when PRs are created or updated. Required Configurations gitStream Create a .cm/gitstream.cm rules file in your repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on the repo, and you can name it anything you want as long as it ends in .cm Here is an example of a gitStream configuration file you can use to setup some basic workflow automations. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. suggest_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} Github Actions Once your gitStream configuration file is setup, you need a Github Actions configuration file to trigger gitStream automations. Create a .github/workflows/gitstream.yml file in your repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream GitHub app - DO NOT EDIT name : gitStream workflow automation run-name : | /:\\ gitStream: PR #$ {{ fromJSON ( fromJSON ( github.event.inputs.client_payload )) .pullRequestNumber }} from $ {{ github.event.inputs.full_repository }} on : workflow_dispatch : inputs : client_payload : description : The Client payload required : true full_repository : description : the repository name include the owner in `owner/repo_name` format required : true head_ref : description : the head sha required : true base_ref : description : the base ref required : true installation_id : description : the installation id required : false resolver_url : description : the resolver url to pass results to required : true resolver_token : description : Optional resolver token for resolver service required : false default : '' jobs : gitStream : timeout-minutes : 5 runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1 id : rules-engine with : full_repository : $ {{ github.event.inputs.full_repository }} head_ref : $ {{ github.event.inputs.head_ref }} base_ref : $ {{ github.event.inputs.base_ref }} client_payload : $ {{ github.event.inputs.client_payload }} installation_id : $ {{ github.event.inputs.installation_id }} resolver_url : $ {{ github.event.inputs.resolver_url }} resolver_token : $ {{ github.event.inputs.resolver_token }} Success When finished, you should have the following file structure in your repo. . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml GitHub Organization Setup Organization rules are ideal when you want to enforce consistent rules across every repo in your organization. You can define them by creating a special repository named cm in your GitHub organization where you can add automation files that will apply to all repositories within that organization. Prerequisite: Create a cm repo and enable gitStream. Organization-wide automations need to be defined in a repo named \"cm\" inside your GitHub organization. Before continuing, you must create this repo and enable the gitStream app for it . Required Configurations gitStream Create a gitstream.cm rules file in the root directory of your cm repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on your organization's repos. You can name it anything you want as long as it ends in .cm Configuration files go in the repo's root directory. Unlike the set up instructions for a single repo, your .cm files should be placed in the repository's root directory. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. suggest_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} GitHub Actions Once your gitStream configuration file is set up, you will need to create a Github Actions configuration file to trigger gitStream automations. Create a .github/workflows/gitstream.yml file in your cm repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream GitHub app - DO NOT EDIT name : gitStream workflow automation run-name : | /:\\ gitStream: PR #$ {{ fromJSON ( fromJSON ( github.event.inputs.client_payload )) .pullRequestNumber }} from $ {{ github.event.inputs.full_repository }} on : workflow_dispatch : inputs : client_payload : description : The Client payload required : true full_repository : description : the repository name include the owner in `owner/repo_name` format required : true head_ref : description : the head sha required : true base_ref : description : the base ref required : true installation_id : description : the installation id required : false resolver_url : description : the resolver url to pass results to required : true resolver_token : description : Optional resolver token for resolver service required : false default : '' jobs : gitStream : timeout-minutes : 5 runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1 id : rules-engine with : full_repository : $ {{ github.event.inputs.full_repository }} head_ref : $ {{ github.event.inputs.head_ref }} base_ref : $ {{ github.event.inputs.base_ref }} client_payload : $ {{ github.event.inputs.client_payload }} installation_id : $ {{ github.event.inputs.installation_id }} resolver_url : $ {{ github.event.inputs.resolver_url }} resolver_token : $ {{ github.event.inputs.resolver_token }} Success Once finished, all PRs to your organization's repositories will be processed by the GitHub Action in this repo, and your cm repo should have a file directory that looks like this. . \u251c\u2500 gitstream.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml gitStream will now do these two things. When a PR is created or changed, apply or update a label that provides an estimated time to review. When a new PR is created, comment with a list of code experts. Next Step How gitStream Works Read our guide: How gitStream Works to get an overview of the gitStream syntax and automation lifecycle. Additional Resources Required GitHub Permissions Permissions Reason Write access to dedicated gitStream app files Used to set up the gitStream workflow files Write access to code To allow gitStream to approve PRs once all conditions are met Read access to administration, issues, and metadata To get the user team membership, and branch protection settings Read and write access to actions, checks, pull requests, and workflows Trigger workflows, create and update pull requests and their checks, and modify workflow files User email Used to identify users Configure gitStream to Block Merges You can configure Github to require gitStream checks to pass before PRs can be merged using branch protection rules . Run a gitStream check before continuing You need to run a check using your gitStream configuration at least once before it can be set as a required check. Make sure to open at least 1 PR before doing this setting. Here are the steps to configure gitStream in your repo's branch protection rules. Go to repo settings On the left panel select Code and automation > Branches Set Branch protection rules for your desired branch Enable Require status checks to pass before merging Search for status checks in the last week for this repository Select gitStream.cm as required check Uninstalling gitStream Configure in your GitHub organization , and choose Uninstall \"gitStream.cm\"","title":"GitHub Setup"},{"location":"github-installation/#how-to-setup-gitstream-with-github","text":"Install gitStream Before you can complete the gitStream setup process, you need to install the gitStream app to your GitHub organization .","title":"How to Setup gitStream with GitHub"},{"location":"github-installation/#setup","text":"You can set up gitStream for a single repo or your entire GitHub organization. Select the tab below for the instructions you want. Single Repo GitHub Organization Single Repo Setup You must implement two main components for gitStream to function for a single GitHub repo. The first is a configuration file that defines the workflow automations to execute for the repo. The second is a GitHub actions configuration file that triggers gitStream when PRs are created or updated. Required Configurations gitStream Create a .cm/gitstream.cm rules file in your repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on the repo, and you can name it anything you want as long as it ends in .cm Here is an example of a gitStream configuration file you can use to setup some basic workflow automations. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. suggest_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} Github Actions Once your gitStream configuration file is setup, you need a Github Actions configuration file to trigger gitStream automations. Create a .github/workflows/gitstream.yml file in your repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream GitHub app - DO NOT EDIT name : gitStream workflow automation run-name : | /:\\ gitStream: PR #$ {{ fromJSON ( fromJSON ( github.event.inputs.client_payload )) .pullRequestNumber }} from $ {{ github.event.inputs.full_repository }} on : workflow_dispatch : inputs : client_payload : description : The Client payload required : true full_repository : description : the repository name include the owner in `owner/repo_name` format required : true head_ref : description : the head sha required : true base_ref : description : the base ref required : true installation_id : description : the installation id required : false resolver_url : description : the resolver url to pass results to required : true resolver_token : description : Optional resolver token for resolver service required : false default : '' jobs : gitStream : timeout-minutes : 5 runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1 id : rules-engine with : full_repository : $ {{ github.event.inputs.full_repository }} head_ref : $ {{ github.event.inputs.head_ref }} base_ref : $ {{ github.event.inputs.base_ref }} client_payload : $ {{ github.event.inputs.client_payload }} installation_id : $ {{ github.event.inputs.installation_id }} resolver_url : $ {{ github.event.inputs.resolver_url }} resolver_token : $ {{ github.event.inputs.resolver_token }} Success When finished, you should have the following file structure in your repo. . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml GitHub Organization Setup Organization rules are ideal when you want to enforce consistent rules across every repo in your organization. You can define them by creating a special repository named cm in your GitHub organization where you can add automation files that will apply to all repositories within that organization. Prerequisite: Create a cm repo and enable gitStream. Organization-wide automations need to be defined in a repo named \"cm\" inside your GitHub organization. Before continuing, you must create this repo and enable the gitStream app for it . Required Configurations gitStream Create a gitstream.cm rules file in the root directory of your cm repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on your organization's repos. You can name it anything you want as long as it ends in .cm Configuration files go in the repo's root directory. Unlike the set up instructions for a single repo, your .cm files should be placed in the repository's root directory. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. suggest_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} GitHub Actions Once your gitStream configuration file is set up, you will need to create a Github Actions configuration file to trigger gitStream automations. Create a .github/workflows/gitstream.yml file in your cm repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream GitHub app - DO NOT EDIT name : gitStream workflow automation run-name : | /:\\ gitStream: PR #$ {{ fromJSON ( fromJSON ( github.event.inputs.client_payload )) .pullRequestNumber }} from $ {{ github.event.inputs.full_repository }} on : workflow_dispatch : inputs : client_payload : description : The Client payload required : true full_repository : description : the repository name include the owner in `owner/repo_name` format required : true head_ref : description : the head sha required : true base_ref : description : the base ref required : true installation_id : description : the installation id required : false resolver_url : description : the resolver url to pass results to required : true resolver_token : description : Optional resolver token for resolver service required : false default : '' jobs : gitStream : timeout-minutes : 5 runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1 id : rules-engine with : full_repository : $ {{ github.event.inputs.full_repository }} head_ref : $ {{ github.event.inputs.head_ref }} base_ref : $ {{ github.event.inputs.base_ref }} client_payload : $ {{ github.event.inputs.client_payload }} installation_id : $ {{ github.event.inputs.installation_id }} resolver_url : $ {{ github.event.inputs.resolver_url }} resolver_token : $ {{ github.event.inputs.resolver_token }} Success Once finished, all PRs to your organization's repositories will be processed by the GitHub Action in this repo, and your cm repo should have a file directory that looks like this. . \u251c\u2500 gitstream.cm \u251c\u2500 .github/ \u2502 \u2514\u2500 workflows/ \u2502 \u2514\u2500 gitstream.yml gitStream will now do these two things. When a PR is created or changed, apply or update a label that provides an estimated time to review. When a new PR is created, comment with a list of code experts.","title":"Setup"},{"location":"github-installation/#next-step","text":"How gitStream Works Read our guide: How gitStream Works to get an overview of the gitStream syntax and automation lifecycle.","title":"Next Step"},{"location":"github-installation/#additional-resources","text":"","title":"Additional Resources"},{"location":"github-installation/#required-github-permissions","text":"Permissions Reason Write access to dedicated gitStream app files Used to set up the gitStream workflow files Write access to code To allow gitStream to approve PRs once all conditions are met Read access to administration, issues, and metadata To get the user team membership, and branch protection settings Read and write access to actions, checks, pull requests, and workflows Trigger workflows, create and update pull requests and their checks, and modify workflow files User email Used to identify users","title":"Required GitHub Permissions"},{"location":"github-installation/#configure-gitstream-to-block-merges","text":"You can configure Github to require gitStream checks to pass before PRs can be merged using branch protection rules . Run a gitStream check before continuing You need to run a check using your gitStream configuration at least once before it can be set as a required check. Make sure to open at least 1 PR before doing this setting. Here are the steps to configure gitStream in your repo's branch protection rules. Go to repo settings On the left panel select Code and automation > Branches Set Branch protection rules for your desired branch Enable Require status checks to pass before merging Search for status checks in the last week for this repository Select gitStream.cm as required check","title":"Configure gitStream to Block Merges "},{"location":"github-installation/#uninstalling-gitstream","text":"Configure in your GitHub organization , and choose Uninstall \"gitStream.cm\"","title":"Uninstalling gitStream"},{"location":"github-org-level/","text":"Deprecated","title":"Github org level"},{"location":"github-required-check/","text":"Deprecated","title":"Github required check"},{"location":"gitlab-installation/","text":"How to Setup gitStream with GitLab Prerequisites GitLab cloud GitLab runner v15 or higher Tip gitStream automation rules are executed on behalf of the user account used to install it, and this account must have the Maintainer role. We recommend creating a new dedicated account (e.g. gitstream-cm ) in GitLab to install the gitStream app. Setup You can set up gitStream for a single repo or your entire GitLab organization. Select the tab below for the instructions you want. Single Repo GitLab Group Single Repo Setup You must implement two main components for gitStream to function for a single GitLab repo. The first is a configuration file that defines the workflow automations to execute for the repo. The second is a GitLab actions configuration file that triggers gitStream when PRs are created or updated which is hosted in a special cm repo. Prerequisite: Create a cm repo and enable gitStream. Create a cm project (repository) in your GitLab group. It should be created in the same group or a parent group of the target repositories Required Configurations gitStream Create a .cm/gitstream.cm rules file in your repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on the repo, and you can name it anything you want as long as it ends in .cm Here is an example of a gitStream configuration file you can use to setup some basic workflow automations. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. suggest_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} GitLab CI Once your gitStream configuration file is setup, you need a GitLab CI configuration file to trigger gitStream automations. Create a new cm project (repository) in your GitLab group. It should be created in the same group or a parent group of the target repositories. Create a .gitlab-ci.yml file in your new cm repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream - DO NOT EDIT stages : - gitstream-main image : docker:latest services : - docker:dind before_script : - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY gitstream-job : stage : gitstream-main only : variables : - $GITSTREAM_MAIN_JOB except : variables : - $GITSTREAM_BLOCK_MERGE script : - apk update && apk add git && apk add docker - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${repoUrl} gitstream/repo - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${cmUrl} gitstream/cm - cd gitstream && cd repo && git fetch --all && git checkout $base_ref && git pull && ls && git checkout $head_ref && git pull && ls - docker pull gitstream/rules-engine:latest - | docker run -v $CI_PROJECT_DIR/gitstream:/code \\ -e HEAD_REF=$head_ref \\ -e BASE_REF=$base_ref \\ -e CLIENT_PAYLOAD=\"$client_payload\" \\ -e RULES_RESOLVER_URL=$resolver_url \\ -e RULES_RESOLVER_TOKEN=$resolver_token \\ -e DEBUG_MODE=true gitstream/rules-engine:latest Success When finished, you should have the following file structure in your cm repo. . \u251c\u2500 .gitlab-ci.yml And in your target repository: . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm GitLab Group Setup Organization rules are ideal when you want to enforce consistent rules across every repo in your organization. You can define them by creating a special repository named cm in your GitLab organization top group where you can add automation files that will apply to all repositories within that organization. Prerequisite: Create a cm repo and enable gitStream. Create a cm project (repository) in your GitLab group. It should be created in the same group or a parent group of the target repositories Required Configurations gitStream Create a gitstream.cm rules file in the root directory of your cm repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on your organization's repos. You can name it anything you want as long as it ends in .cm Configuration files go in the repo's root directory. Unlike the set up instructions for a single repo, your .cm files should be placed in the repository's root directory. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. suggest_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} GitLab CI Once your gitStream configuration file is setup, you need a GitLab CI configuration file to trigger gitStream automations. Create a .gitlab-ci.yml file in your new cm repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream - DO NOT EDIT stages : - gitstream-main image : docker:latest services : - docker:dind before_script : - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY gitstream-job : stage : gitstream-main only : variables : - $GITSTREAM_MAIN_JOB except : variables : - $GITSTREAM_BLOCK_MERGE script : - apk update && apk add git && apk add docker - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${repoUrl} gitstream/repo - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${cmUrl} gitstream/cm - cd gitstream && cd repo && git fetch --all && git checkout $base_ref && git pull && ls && git checkout $head_ref && git pull && ls - docker pull gitstream/rules-engine:latest - | docker run -v $CI_PROJECT_DIR/gitstream:/code \\ -e HEAD_REF=$head_ref \\ -e BASE_REF=$base_ref \\ -e CLIENT_PAYLOAD=\"$client_payload\" \\ -e RULES_RESOLVER_URL=$resolver_url \\ -e RULES_RESOLVER_TOKEN=$resolver_token \\ -e DEBUG_MODE=true gitstream/rules-engine:latest Success When finished, you should have the following file structure in your cm repo. . \u251c\u2500 .gitlab-ci.yml \u251c\u2500 gitstream.cm Install gitStream App Install gitStream The last step of the process is to install the gitStream app to your GitLab organization . gitStream will now do these two things. When a PR is created or changed, apply or update a label that provides an estimated time to review. When a suggest-reviewers label is applied to a PR, gitStream will comment with a list of code experts. Attention When renaming or adding new repositories, you must re-authenticate gitStream in GitLab Next Step How gitStream Works Read our guide: How gitStream Works to get an overview of the gitStream syntax and automation lifecycle. Additional Resources Required GitLab Permissions The required permissions are: Permissions Reason Read/Write API To get notified on MR changes and allow gitStream to approve MRs once all conditions are met Read repository To read and check rules over the code changes on monitored repositories Read user profile Used to identify users No support for gitStream to Block Merges gitStream actions that blocks MR merge are not support at the moment. gitStream service account Automation rules by gitStream are executed on behalf of the user account used to install it. We recommend using a new dedicated account in GitLab for installing gitStream, e.g. gitstream-cm Uninstalling gitStream Use the following link to uninstall gitStream app for GitLab . Attention The uninstalling account has to have at least Developer or Maintainer role in the Group.","title":"GitLab Setup"},{"location":"gitlab-installation/#how-to-setup-gitstream-with-gitlab","text":"Prerequisites GitLab cloud GitLab runner v15 or higher Tip gitStream automation rules are executed on behalf of the user account used to install it, and this account must have the Maintainer role. We recommend creating a new dedicated account (e.g. gitstream-cm ) in GitLab to install the gitStream app.","title":"How to Setup gitStream with GitLab"},{"location":"gitlab-installation/#setup","text":"You can set up gitStream for a single repo or your entire GitLab organization. Select the tab below for the instructions you want. Single Repo GitLab Group Single Repo Setup You must implement two main components for gitStream to function for a single GitLab repo. The first is a configuration file that defines the workflow automations to execute for the repo. The second is a GitLab actions configuration file that triggers gitStream when PRs are created or updated which is hosted in a special cm repo. Prerequisite: Create a cm repo and enable gitStream. Create a cm project (repository) in your GitLab group. It should be created in the same group or a parent group of the target repositories Required Configurations gitStream Create a .cm/gitstream.cm rules file in your repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on the repo, and you can name it anything you want as long as it ends in .cm Here is an example of a gitStream configuration file you can use to setup some basic workflow automations. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. suggest_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} GitLab CI Once your gitStream configuration file is setup, you need a GitLab CI configuration file to trigger gitStream automations. Create a new cm project (repository) in your GitLab group. It should be created in the same group or a parent group of the target repositories. Create a .gitlab-ci.yml file in your new cm repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream - DO NOT EDIT stages : - gitstream-main image : docker:latest services : - docker:dind before_script : - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY gitstream-job : stage : gitstream-main only : variables : - $GITSTREAM_MAIN_JOB except : variables : - $GITSTREAM_BLOCK_MERGE script : - apk update && apk add git && apk add docker - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${repoUrl} gitstream/repo - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${cmUrl} gitstream/cm - cd gitstream && cd repo && git fetch --all && git checkout $base_ref && git pull && ls && git checkout $head_ref && git pull && ls - docker pull gitstream/rules-engine:latest - | docker run -v $CI_PROJECT_DIR/gitstream:/code \\ -e HEAD_REF=$head_ref \\ -e BASE_REF=$base_ref \\ -e CLIENT_PAYLOAD=\"$client_payload\" \\ -e RULES_RESOLVER_URL=$resolver_url \\ -e RULES_RESOLVER_TOKEN=$resolver_token \\ -e DEBUG_MODE=true gitstream/rules-engine:latest Success When finished, you should have the following file structure in your cm repo. . \u251c\u2500 .gitlab-ci.yml And in your target repository: . \u251c\u2500 .cm/ \u2502 \u2514\u2500 gitstream.cm GitLab Group Setup Organization rules are ideal when you want to enforce consistent rules across every repo in your organization. You can define them by creating a special repository named cm in your GitLab organization top group where you can add automation files that will apply to all repositories within that organization. Prerequisite: Create a cm repo and enable gitStream. Create a cm project (repository) in your GitLab group. It should be created in the same group or a parent group of the target repositories Required Configurations gitStream Create a gitstream.cm rules file in the root directory of your cm repository's default branch (usually master or main ). This file will contain a YAML configuration that determines the workflows that run on your organization's repos. You can name it anything you want as long as it ends in .cm Configuration files go in the repo's root directory. Unlike the set up instructions for a single repo, your .cm files should be placed in the repository's root directory. # -*- mode: yaml -*- # This example configuration for provides basic automations to get started with gitStream. # View the gitStream quickstart for more examples: https://docs.gitstream.cm/quick-start/ manifest : version : 1.0 automations : # Add a label that indicates how many minutes it will take to review the PR. estimated_time_to_review : if : - true run : - action : add-label@v1 # etr is defined in the last section of this example args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} # Post a comment that lists the best experts for the files that were modified. suggest_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} # The next function calculates the estimated time to review and makes it available in the automation above. calc : etr : {{ branch | estimatedReviewTime }} GitLab CI Once your gitStream configuration file is setup, you need a GitLab CI configuration file to trigger gitStream automations. Create a .gitlab-ci.yml file in your new cm repository's default branch (usually master or main ) and add the following configuration: # Code generated by gitStream - DO NOT EDIT stages : - gitstream-main image : docker:latest services : - docker:dind before_script : - docker login -u \"$CI_REGISTRY_USER\" -p \"$CI_REGISTRY_PASSWORD\" $CI_REGISTRY gitstream-job : stage : gitstream-main only : variables : - $GITSTREAM_MAIN_JOB except : variables : - $GITSTREAM_BLOCK_MERGE script : - apk update && apk add git && apk add docker - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${repoUrl} gitstream/repo - git clone https://gitlab-ci-token:${CI_JOB_TOKEN}${cmUrl} gitstream/cm - cd gitstream && cd repo && git fetch --all && git checkout $base_ref && git pull && ls && git checkout $head_ref && git pull && ls - docker pull gitstream/rules-engine:latest - | docker run -v $CI_PROJECT_DIR/gitstream:/code \\ -e HEAD_REF=$head_ref \\ -e BASE_REF=$base_ref \\ -e CLIENT_PAYLOAD=\"$client_payload\" \\ -e RULES_RESOLVER_URL=$resolver_url \\ -e RULES_RESOLVER_TOKEN=$resolver_token \\ -e DEBUG_MODE=true gitstream/rules-engine:latest Success When finished, you should have the following file structure in your cm repo. . \u251c\u2500 .gitlab-ci.yml \u251c\u2500 gitstream.cm","title":"Setup"},{"location":"gitlab-installation/#install-gitstream-app","text":"Install gitStream The last step of the process is to install the gitStream app to your GitLab organization . gitStream will now do these two things. When a PR is created or changed, apply or update a label that provides an estimated time to review. When a suggest-reviewers label is applied to a PR, gitStream will comment with a list of code experts. Attention When renaming or adding new repositories, you must re-authenticate gitStream in GitLab","title":"Install gitStream App"},{"location":"gitlab-installation/#next-step","text":"How gitStream Works Read our guide: How gitStream Works to get an overview of the gitStream syntax and automation lifecycle.","title":"Next Step"},{"location":"gitlab-installation/#additional-resources","text":"","title":"Additional Resources"},{"location":"gitlab-installation/#required-gitlab-permissions","text":"The required permissions are: Permissions Reason Read/Write API To get notified on MR changes and allow gitStream to approve MRs once all conditions are met Read repository To read and check rules over the code changes on monitored repositories Read user profile Used to identify users","title":"Required GitLab Permissions"},{"location":"gitlab-installation/#no-support-for-gitstream-to-block-merges","text":"gitStream actions that blocks MR merge are not support at the moment.","title":"No support for gitStream to Block Merges"},{"location":"gitlab-installation/#gitstream-service-account","text":"Automation rules by gitStream are executed on behalf of the user account used to install it. We recommend using a new dedicated account in GitLab for installing gitStream, e.g. gitstream-cm","title":"gitStream service account"},{"location":"gitlab-installation/#uninstalling-gitstream","text":"Use the following link to uninstall gitStream app for GitLab . Attention The uninstalling account has to have at least Developer or Maintainer role in the Group.","title":"Uninstalling gitStream"},{"location":"how-it-works/","text":"How gitStream Works You can configure gitStream via one or more Continuous Merge (CM) files inside your git repository or GitHub/GitLab organization. These files end with a .cm extension, and they outline automations that will run whenever someone opens a new PR or makes changes to an existing PR. Syntax Overview CM files contain a combination of YAML and Jinja2 to build rules that follow an \"if this, then that\" approach to triggering and executing automations. This, combined with templating and gitStream-specific functions gives you a highly-flexible framework for building custom CM automations. All CM files must have a section that starts with automations: that contains one or more custom automations that will trigger for the repo. gitStream is triggered every time someone opens a new PR or changes an existing PR. Once activated, gitStream searches for applicable CM files and executes the automations that are listed inside them. Here is an example of the basic components that are required in every CM file. Required CM Components Please note, this is not a valid CM automation, it is only for illustrative purposes. # -*- mode: yaml -*- manifest : version : 1.0 automations : my_automation : if : - # Add a condition here run : - # Add an automation here Info When editing CM files, make sure you preserve the indentation in the examples because, like YAML, gitStream uses Python-style indentation to indicate nesting. Automation Actions Automation actions specify the desired automations that should be triggered when all conditions are met. Each automation must incliude an if condition and a run section. The conditions are evaluated whenever someone creates a PR or makes changes to an existing PR; multiple conditions can be listed for a single automation, but they must all be true to invoke the actions. You can have any number of actions listed in an automation and they are invoked one-by-one in no particular order. PRs that are marked as Draft are ignored by default, but you can change that in your config . Basic Automation Example This example defines an automation named welcome_newcomer that post a comment to welcome anyone who submits their first PR to the repo. automations : welcome_newcomer : if : - {{ repo.contributors | isFirstCommit ( branch.author ) }} run : - action : add-comment@v1 args : comment : Welcome {{ branch.author }} ! Context Variables and Filter Functions Context variables are pre-defined objects that gitStream provides as the input data you will need to build your automations. These variables enable you to access information about things like the file names and paths, the person who submitted the PR, or what code was changed. Filter functions are functions you can call and apply to variables. They are called with a pipe operator | and can take arguments inside parentheses ( ) . The logic expressions are based on Jinja2 syntax, supported by the Nunjucks library . Context Variable and Filter Function Example The following statement passes the context variable files to the filter function match which uses an optional list of sensitive filepaths that would need to be defined later in the CM file, and returns true if any of the files match the list as indicated by the some filter function. {{ files | match ( list = sensitive ) | some }} You can also apply Nunjucks logic operators to filters Logic Operators Example This example inverts the previous example using the keyword not . {{ not ( files | match ( list = sensitive ) | some ) }} Custom Expressions Jinja templating makes it easy to write custom expressions that can be invoked elsewhere in your CM files. This makes it easy to reuse data, define custom criteria, and keep your configuration files cleaner so they're easier to manage. Custom Expressions Example This example contains two custom expressions; is: contains a context variable and some filter functions that are invoked in the sensitive_review automation via is.sensitive , and sensitive directories contains a list of directory paths that will be matched in the filter function. automations : sensitive_review : if : - is.sensitive run : - action : set-required-approvals@v1 args : approvals : 2 is : sensitive : {{ files | match ( list = sensitive_directories ) | some }} sensitive_directories : - src/app/auth/ - src/app/routing/ - src/app/resources/ Ignore Files or Repos You can provide gitStream with a list of specific files to ignore for all automations listed in the same CM file. To do so, add a configuration: section to the CM file that you want to apply the exclusion list to. In the configuration section, add a list of files as an argument to the ignore_files: key. How to Ignore Files To ignore a list of files, add a config.ignore_files to you CM file like this: config : ignore_files : - 'yarn.lock' - 'package-lock.json' - 'openapi.json' - 'ui/src/**/*Model.d.ts' Similarly, if you are using gitStream for your entire git organization, you can specify repos to ignore in the gitstream.cm file in the root directory of your cm repo. How to Ignore Repos config : ignore_repositories : - services - common Configuration Priority and Overrides You can provide any number of CM files and automations for gitStream to process and you can freely combine organization-level automations with automations inside individual repos. There are two important things you need to keep in mind when doing this. First, when a repository defines the same automation as an organization-level rule, the repository automation will take precedence and override the organization automation. The CM file name and the automation name must both match for this to take effect because gitStream identifies all automations based on a combination of both. For example, if you have a gitstream.cm file that contains an automation named my_automation , gitStream will identify that as gitstream/my_automation . Second, no priority is given to individual automations. Instead, gitStream collects all applicable automations for a given PR and processes them all at once. Next Step Write your first automation. The best way to familiarize yourself with CM syntax is to build automations, and we've covered enough info for you to start! If you're ready to start writing automations, check out our guide: Write Your First Automation . Additional Resources Functional Overview Once gitStream is installed and configured, there are several services that will interact with your repository whenever a PR is created or changed: The git service provider API (e.g. GitHub, Gitlab) The gitStream service that was installed from the git service provider marketplace. A gitStream CI/CD script that is configured for the git service provider (e.g. GitHub Actions, GitLab CI/CD). A gitStream agent the CI/CD script triggers to execute your automation. Whenever a new PR is opened or an existing PR is changed, the following process occurs: The git service provider API notifies the gitStream service that an applicable change has occured to the PR which triggers a call to execute the gitStream CI/CD script . The gitStream CI/CD script executes the GitHub Action linear-b/gitstream-github-action@v1 on the repository, which looks for two things: Valid CM files that match the filepath .cm/*.cm Any CM files that are contained in the root directory of the organization's cm repo (if applicable). The gitStream CI/CD script passes all CM metadata to the gitStream agent which parses a list of all applicable CM rules. The GitStream agent provides the list of applicable automations to the gitStream service . The gitStream service iterates through the automations and updates the PR via the git service provider API . Here is a diagram that illustrates how things work behind the scenes: sequenceDiagram autonumber Git Provider API->>gitStream app: PR Notification activate gitStream app gitStream app->>gitStream CI/CD script: Execute CI/CD Action activate gitStream CI/CD script gitStream CI/CD script->>gitStream agent: CM Metadata activate gitStream agent gitStream agent->>gitStream app: Applicable Automations deactivate gitStream agent deactivate gitStream CI/CD script loop Automations loop Actions gitStream app->>Git Provider API: Update PR end end deactivate gitStream app Upon completion, gitStream will show one of the following three statuses: Success - when the applicable automation finished and PR is good to go Neutral - when there aren't any applicable automations for the PR Failed - when the applicable automation finished without completion gitStream checks have a 10-minute timeout for fail-safe reasons. If the check exceeds this time limit, the result will be displayed as Neutral - Skipped . Reserved Words Avoid using these words when naming your automations, actions, or other components. gitStream reserved words: allDocs allImages allTests automations codeExperts config estimaterReviewTime explainCodeExperts explainRankByGitBlame extractJitFindings extractSonarFindings extensions every filter includes isFirstCommit isFormattingChange manifest map mapToEnum match matchDiffLines nope rankByGitActivity rankByGitBlame reject some Nunjucks reserved words: abs asyncAll asyncEach batch block call capitalize center default dictsort dump e escape extends filter first float for forceescape groupby if import include indent int join last length list lower macro nl2br raw reject rejectattr replace reverse round safe select selectattr set slice sort string striptags sum title trim truncate upper urlencode urlize verbatim wordcount Syntax highlighting You can add support for .cm in your code editor, see FAQ . Is something missing? If you find an issue with these docs or with gitStream itself, please search the gitStream issues page and create an issue if one doesn't already exist for your problem.","title":"How gitStream works"},{"location":"how-it-works/#how-gitstream-works","text":"You can configure gitStream via one or more Continuous Merge (CM) files inside your git repository or GitHub/GitLab organization. These files end with a .cm extension, and they outline automations that will run whenever someone opens a new PR or makes changes to an existing PR.","title":"How gitStream Works"},{"location":"how-it-works/#syntax-overview","text":"CM files contain a combination of YAML and Jinja2 to build rules that follow an \"if this, then that\" approach to triggering and executing automations. This, combined with templating and gitStream-specific functions gives you a highly-flexible framework for building custom CM automations. All CM files must have a section that starts with automations: that contains one or more custom automations that will trigger for the repo. gitStream is triggered every time someone opens a new PR or changes an existing PR. Once activated, gitStream searches for applicable CM files and executes the automations that are listed inside them. Here is an example of the basic components that are required in every CM file. Required CM Components Please note, this is not a valid CM automation, it is only for illustrative purposes. # -*- mode: yaml -*- manifest : version : 1.0 automations : my_automation : if : - # Add a condition here run : - # Add an automation here Info When editing CM files, make sure you preserve the indentation in the examples because, like YAML, gitStream uses Python-style indentation to indicate nesting.","title":"Syntax Overview"},{"location":"how-it-works/#automation-actions","text":"Automation actions specify the desired automations that should be triggered when all conditions are met. Each automation must incliude an if condition and a run section. The conditions are evaluated whenever someone creates a PR or makes changes to an existing PR; multiple conditions can be listed for a single automation, but they must all be true to invoke the actions. You can have any number of actions listed in an automation and they are invoked one-by-one in no particular order. PRs that are marked as Draft are ignored by default, but you can change that in your config . Basic Automation Example This example defines an automation named welcome_newcomer that post a comment to welcome anyone who submits their first PR to the repo. automations : welcome_newcomer : if : - {{ repo.contributors | isFirstCommit ( branch.author ) }} run : - action : add-comment@v1 args : comment : Welcome {{ branch.author }} !","title":"Automation Actions"},{"location":"how-it-works/#context-variables-and-filter-functions","text":"Context variables are pre-defined objects that gitStream provides as the input data you will need to build your automations. These variables enable you to access information about things like the file names and paths, the person who submitted the PR, or what code was changed. Filter functions are functions you can call and apply to variables. They are called with a pipe operator | and can take arguments inside parentheses ( ) . The logic expressions are based on Jinja2 syntax, supported by the Nunjucks library . Context Variable and Filter Function Example The following statement passes the context variable files to the filter function match which uses an optional list of sensitive filepaths that would need to be defined later in the CM file, and returns true if any of the files match the list as indicated by the some filter function. {{ files | match ( list = sensitive ) | some }} You can also apply Nunjucks logic operators to filters Logic Operators Example This example inverts the previous example using the keyword not . {{ not ( files | match ( list = sensitive ) | some ) }}","title":"Context Variables and Filter Functions"},{"location":"how-it-works/#custom-expressions","text":"Jinja templating makes it easy to write custom expressions that can be invoked elsewhere in your CM files. This makes it easy to reuse data, define custom criteria, and keep your configuration files cleaner so they're easier to manage. Custom Expressions Example This example contains two custom expressions; is: contains a context variable and some filter functions that are invoked in the sensitive_review automation via is.sensitive , and sensitive directories contains a list of directory paths that will be matched in the filter function. automations : sensitive_review : if : - is.sensitive run : - action : set-required-approvals@v1 args : approvals : 2 is : sensitive : {{ files | match ( list = sensitive_directories ) | some }} sensitive_directories : - src/app/auth/ - src/app/routing/ - src/app/resources/","title":"Custom Expressions"},{"location":"how-it-works/#ignore-files-or-repos","text":"You can provide gitStream with a list of specific files to ignore for all automations listed in the same CM file. To do so, add a configuration: section to the CM file that you want to apply the exclusion list to. In the configuration section, add a list of files as an argument to the ignore_files: key. How to Ignore Files To ignore a list of files, add a config.ignore_files to you CM file like this: config : ignore_files : - 'yarn.lock' - 'package-lock.json' - 'openapi.json' - 'ui/src/**/*Model.d.ts' Similarly, if you are using gitStream for your entire git organization, you can specify repos to ignore in the gitstream.cm file in the root directory of your cm repo. How to Ignore Repos config : ignore_repositories : - services - common","title":"Ignore Files or Repos"},{"location":"how-it-works/#configuration-priority-and-overrides","text":"You can provide any number of CM files and automations for gitStream to process and you can freely combine organization-level automations with automations inside individual repos. There are two important things you need to keep in mind when doing this. First, when a repository defines the same automation as an organization-level rule, the repository automation will take precedence and override the organization automation. The CM file name and the automation name must both match for this to take effect because gitStream identifies all automations based on a combination of both. For example, if you have a gitstream.cm file that contains an automation named my_automation , gitStream will identify that as gitstream/my_automation . Second, no priority is given to individual automations. Instead, gitStream collects all applicable automations for a given PR and processes them all at once.","title":"Configuration Priority and Overrides"},{"location":"how-it-works/#next-step","text":"Write your first automation. The best way to familiarize yourself with CM syntax is to build automations, and we've covered enough info for you to start! If you're ready to start writing automations, check out our guide: Write Your First Automation .","title":"Next Step"},{"location":"how-it-works/#additional-resources","text":"","title":"Additional Resources"},{"location":"how-it-works/#functional-overview","text":"Once gitStream is installed and configured, there are several services that will interact with your repository whenever a PR is created or changed: The git service provider API (e.g. GitHub, Gitlab) The gitStream service that was installed from the git service provider marketplace. A gitStream CI/CD script that is configured for the git service provider (e.g. GitHub Actions, GitLab CI/CD). A gitStream agent the CI/CD script triggers to execute your automation. Whenever a new PR is opened or an existing PR is changed, the following process occurs: The git service provider API notifies the gitStream service that an applicable change has occured to the PR which triggers a call to execute the gitStream CI/CD script . The gitStream CI/CD script executes the GitHub Action linear-b/gitstream-github-action@v1 on the repository, which looks for two things: Valid CM files that match the filepath .cm/*.cm Any CM files that are contained in the root directory of the organization's cm repo (if applicable). The gitStream CI/CD script passes all CM metadata to the gitStream agent which parses a list of all applicable CM rules. The GitStream agent provides the list of applicable automations to the gitStream service . The gitStream service iterates through the automations and updates the PR via the git service provider API . Here is a diagram that illustrates how things work behind the scenes: sequenceDiagram autonumber Git Provider API->>gitStream app: PR Notification activate gitStream app gitStream app->>gitStream CI/CD script: Execute CI/CD Action activate gitStream CI/CD script gitStream CI/CD script->>gitStream agent: CM Metadata activate gitStream agent gitStream agent->>gitStream app: Applicable Automations deactivate gitStream agent deactivate gitStream CI/CD script loop Automations loop Actions gitStream app->>Git Provider API: Update PR end end deactivate gitStream app Upon completion, gitStream will show one of the following three statuses: Success - when the applicable automation finished and PR is good to go Neutral - when there aren't any applicable automations for the PR Failed - when the applicable automation finished without completion gitStream checks have a 10-minute timeout for fail-safe reasons. If the check exceeds this time limit, the result will be displayed as Neutral - Skipped .","title":"Functional Overview"},{"location":"how-it-works/#reserved-words","text":"Avoid using these words when naming your automations, actions, or other components. gitStream reserved words: allDocs allImages allTests automations codeExperts config estimaterReviewTime explainCodeExperts explainRankByGitBlame extractJitFindings extractSonarFindings extensions every filter includes isFirstCommit isFormattingChange manifest map mapToEnum match matchDiffLines nope rankByGitActivity rankByGitBlame reject some Nunjucks reserved words: abs asyncAll asyncEach batch block call capitalize center default dictsort dump e escape extends filter first float for forceescape groupby if import include indent int join last length list lower macro nl2br raw reject rejectattr replace reverse round safe select selectattr set slice sort string striptags sum title trim truncate upper urlencode urlize verbatim wordcount","title":"Reserved Words"},{"location":"how-it-works/#syntax-highlighting","text":"You can add support for .cm in your code editor, see FAQ .","title":"Syntax highlighting"},{"location":"how-it-works/#is-something-missing","text":"If you find an issue with these docs or with gitStream itself, please search the gitStream issues page and create an issue if one doesn't already exist for your problem.","title":"Is something missing?"},{"location":"quick-start/","text":"Write Your First gitStream Automation This article provides Continuous Merge (CM) examples to help you start customizing gitStream automations to meet the needs of your team. Approve Simple Changes Changes to documentation, testing, and code formatting are often safe enough that there is little to no risk in letting an individual contributor merge those changes without needing to distract other people on their team to meet organization-wide requirements for multiple reviews on PRs. A good first Continuous Merge (CM) automation to implement is one that labels and approves changes to resources that could be considered safe changes. This example uses the filter functions allDocs , allTests , isFormattingChange and match to detect changes that should be safe to merge with minimal review. It then uses the add-label automation action to apply a safe-changes label and the approve automation action to provide an approval review. Label and Approve Simple Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : safe_changes : if : - {{ is .docs or is .tests or is .asset or is .formatting }} run : - action : add-label@v1 args : label : 'safe-changes' - action : approve@v1 is : docs : {{ files | allDocs }} tests : {{ files | allTests }} asset : {{ files | match ( regex = r / \\. ( png | svg | gif | css ) $ /) | every }} formatting : {{ source.diff.files | isFormattingChange }} Test Your Automation in Dry Run Mode gitStream includes a dry-run mode that let's you test your automations on your desired repo without pushing significant code, documentation, or other changes to the repo. Learn more in our guide: How to Test Your Automations . Find Reviewers for Common Changes Selecting the right reviewer for your PR is crucial to ensure that your changes are thoroughly reviewed and that any issues are identified and addressed before they are merged into the main codebase. This example uses the codeExperts filter function to identify the most qualified contributors based on their activity in the repo. It then assigns those individuals as reviewers on the PR with the add-reviewers automation action and posts a comment that lists the code experts via the add-comment automation action. Identify and Assign Code Experts for Reviews This example uses the codeExperts filter function to identify the people who have the most expertise in the relevant code, assigns them as reviewers, and provides a comment that explains how those people were selected. # -*- mode: yaml -*- manifest : version : 1.0 automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Enforce Review Policies for Critical Changes Complex and sensitive PRs often require more nuanced and complex review processes that bring in outside teams of experts to review code changes. gitStream makes it easy to set up custom review policies to keep teams align across your organization. This example contains two automations that implement custom review policies for specific parts of a codebase. First, the security_review automation uses the require-reviewers automation action to add the security team from the git organization as reviewers on PRs that affect the auth directory of the repo. This action accepts a reviewers: argument that contains a list of teams or individual users; you will need to change this value to match your organization and users. Second, the double_review automation forces any changes to the agent directory to require a review from two people using the set-required-approvals automation action. Enforce Review Policies # -*- mode: yaml -*- manifest : version : 1.0 automations : security_review : if : - {{ files | match ( regex = r / auth \\ //) | some }} run : - action : require-reviewers@v1 args : reviewers : [ my_organization/security ] - action : add-reviewers@v1 args : reviewers : [ my_organization/security ] double_review : if : - {{ files | match ( regex = r / agent \\ //) | some }} run : - action : set-required-approvals@v1 args : approvals : 2 Next Step Take a Look at the Quickstart Examples You're ready to browse our CM example library to build more automations for your repo. We have examples that help provide context to PRs with labels, assign reviewers based on custom criteria, manage security requirements, and more.","title":"Your First Automation"},{"location":"quick-start/#write-your-first-gitstream-automation","text":"This article provides Continuous Merge (CM) examples to help you start customizing gitStream automations to meet the needs of your team.","title":"Write Your First gitStream Automation"},{"location":"quick-start/#approve-simple-changes","text":"Changes to documentation, testing, and code formatting are often safe enough that there is little to no risk in letting an individual contributor merge those changes without needing to distract other people on their team to meet organization-wide requirements for multiple reviews on PRs. A good first Continuous Merge (CM) automation to implement is one that labels and approves changes to resources that could be considered safe changes. This example uses the filter functions allDocs , allTests , isFormattingChange and match to detect changes that should be safe to merge with minimal review. It then uses the add-label automation action to apply a safe-changes label and the approve automation action to provide an approval review. Label and Approve Simple Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : safe_changes : if : - {{ is .docs or is .tests or is .asset or is .formatting }} run : - action : add-label@v1 args : label : 'safe-changes' - action : approve@v1 is : docs : {{ files | allDocs }} tests : {{ files | allTests }} asset : {{ files | match ( regex = r / \\. ( png | svg | gif | css ) $ /) | every }} formatting : {{ source.diff.files | isFormattingChange }} Test Your Automation in Dry Run Mode gitStream includes a dry-run mode that let's you test your automations on your desired repo without pushing significant code, documentation, or other changes to the repo. Learn more in our guide: How to Test Your Automations .","title":"Approve Simple Changes"},{"location":"quick-start/#find-reviewers-for-common-changes","text":"Selecting the right reviewer for your PR is crucial to ensure that your changes are thoroughly reviewed and that any issues are identified and addressed before they are merged into the main codebase. This example uses the codeExperts filter function to identify the most qualified contributors based on their activity in the repo. It then assigns those individuals as reviewers on the PR with the add-reviewers automation action and posts a comment that lists the code experts via the add-comment automation action. Identify and Assign Code Experts for Reviews This example uses the codeExperts filter function to identify the people who have the most expertise in the relevant code, assigns them as reviewers, and provides a comment that explains how those people were selected. # -*- mode: yaml -*- manifest : version : 1.0 automations : code_experts : if : - true run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }}","title":"Find Reviewers for Common Changes"},{"location":"quick-start/#enforce-review-policies-for-critical-changes","text":"Complex and sensitive PRs often require more nuanced and complex review processes that bring in outside teams of experts to review code changes. gitStream makes it easy to set up custom review policies to keep teams align across your organization. This example contains two automations that implement custom review policies for specific parts of a codebase. First, the security_review automation uses the require-reviewers automation action to add the security team from the git organization as reviewers on PRs that affect the auth directory of the repo. This action accepts a reviewers: argument that contains a list of teams or individual users; you will need to change this value to match your organization and users. Second, the double_review automation forces any changes to the agent directory to require a review from two people using the set-required-approvals automation action. Enforce Review Policies # -*- mode: yaml -*- manifest : version : 1.0 automations : security_review : if : - {{ files | match ( regex = r / auth \\ //) | some }} run : - action : require-reviewers@v1 args : reviewers : [ my_organization/security ] - action : add-reviewers@v1 args : reviewers : [ my_organization/security ] double_review : if : - {{ files | match ( regex = r / agent \\ //) | some }} run : - action : set-required-approvals@v1 args : approvals : 2","title":"Enforce Review Policies for Critical Changes"},{"location":"quick-start/#next-step","text":"Take a Look at the Quickstart Examples You're ready to browse our CM example library to build more automations for your repo. We have examples that help provide context to PRs with labels, assign reviewers based on custom criteria, manage security requirements, and more.","title":"Next Step"},{"location":"troubleshooting/","text":"Troubleshooting I can't see any action running Did you install gitStream in your repo? Check that you see gitStream app on repository's Settings > GitHub apps: In case you don't see it, visit the marketplace and install it for free: https://github.com/marketplace/gitstream-by-linearb Did you set the workflow files correctly? Check you have placed these 2 files in your repository, with these exact names: .cm/gitstream.cm .github/workflows/gitstream.yml These files need to be committed to the repository default branch (usually master or main ). Notice that the action will not run until these files are found on the default branch. Check that you see \"gitStream workflow automation\" on the Action section in your repository: Next, if you see failed action, check out the details: Some organization limit which actions can run, in that case in the repository settings you should enable it: Is the PR in Draft mode? gitStream automations won't trigger for PRs that in Draft mode. I have rules that should have blocked merge, but the PR can be merged still For example, when using the set-required-approvals action, gitStream can ensure the PR got enough approvals before it can be merged. gitStream does that by running as a check and marking the check conclusion as failed. In order for the PR to be blocked, gitStream should be set as a required check in the repo: instructions here . I can't set gitStream as required check In order for gitStream to be listed as a required check, it needs to be triggered at least once in that repo. First create a new PR so gitStream is triggered. Check it under repository's Settings > Branches: I don't want gitStream to run on PRs that was generated by a bot You can edit the .github/workflows/gitstream.yml and uncomment the if line, you can edit and replace the bot name with the bot name you want to ignore ( dependabot[bot] in the example below): .github/workflows/gitstream.yml jobs : gitStream : timeout-minutes : 5 # uncomment this condition, if you don't want any automation on dependabot PRs if : github.actor != 'dependabot[bot]' runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1 gitStream fails and I don't understand why gitStream check run can fail from different reasons, and these are shown in the check result. Missing workflow file When it says gitStream.cm Skipped \u2014 gitStream workflow file not found , it means that the GitHub action was not found, check again that you have this file in your repository root: .github/workflows/gitstream.yml , see instructions on GitHub installation . Syntax error in the cm files Clicking the Details button will show more information and context. You can add this automation to see details on context variable. How can I debug expressions and see their content? You can dump any context value to the PR comment. For example, to see the list of changed files, use: automations : show_changed_files : if : - true run : - action : add-comment@v1 args : comment : | FILES DUMP {{ files | dump | safe }} JS FILES DUMP {{ files | filter ( regex = r / \\ .js $ /) | dump | safe }} Download and add to your repo .cm directory gitStream fails with syntax error after adding new rules IntelliJ IDEA has automatic code styling for YAML that can break the .cm syntax, check the following Settings/Preferences | Editor | Code Style | YAML --> Spaces | Code braces and make sure it is unchecked. VS Code YAML plugin by Red Hat extension [vscode-yaml](https://github.com/redhat-developer/vscode-yaml) has automatic code styling for YAML that can break the .cm syntax, make sure you disable bracketSpacing { \"yaml.format.bracketSpacing\" : false , } Not here? Create a new issue in the project's issues","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#i-cant-see-any-action-running","text":"Did you install gitStream in your repo? Check that you see gitStream app on repository's Settings > GitHub apps: In case you don't see it, visit the marketplace and install it for free: https://github.com/marketplace/gitstream-by-linearb Did you set the workflow files correctly? Check you have placed these 2 files in your repository, with these exact names: .cm/gitstream.cm .github/workflows/gitstream.yml These files need to be committed to the repository default branch (usually master or main ). Notice that the action will not run until these files are found on the default branch. Check that you see \"gitStream workflow automation\" on the Action section in your repository: Next, if you see failed action, check out the details: Some organization limit which actions can run, in that case in the repository settings you should enable it: Is the PR in Draft mode? gitStream automations won't trigger for PRs that in Draft mode.","title":"I can't see any action running"},{"location":"troubleshooting/#i-have-rules-that-should-have-blocked-merge-but-the-pr-can-be-merged-still","text":"For example, when using the set-required-approvals action, gitStream can ensure the PR got enough approvals before it can be merged. gitStream does that by running as a check and marking the check conclusion as failed. In order for the PR to be blocked, gitStream should be set as a required check in the repo: instructions here .","title":"I have rules that should have blocked merge, but the PR can be merged still"},{"location":"troubleshooting/#i-cant-set-gitstream-as-required-check","text":"In order for gitStream to be listed as a required check, it needs to be triggered at least once in that repo. First create a new PR so gitStream is triggered. Check it under repository's Settings > Branches:","title":"I can't set gitStream as required check"},{"location":"troubleshooting/#i-dont-want-gitstream-to-run-on-prs-that-was-generated-by-a-bot","text":"You can edit the .github/workflows/gitstream.yml and uncomment the if line, you can edit and replace the bot name with the bot name you want to ignore ( dependabot[bot] in the example below): .github/workflows/gitstream.yml jobs : gitStream : timeout-minutes : 5 # uncomment this condition, if you don't want any automation on dependabot PRs if : github.actor != 'dependabot[bot]' runs-on : ubuntu-latest name : gitStream workflow automation steps : - name : Evaluate Rules uses : linear-b/gitstream-github-action@v1","title":"I don't want gitStream to run on PRs that was generated by a bot"},{"location":"troubleshooting/#gitstream-fails-and-i-dont-understand-why","text":"gitStream check run can fail from different reasons, and these are shown in the check result.","title":"gitStream fails and I don't understand why"},{"location":"troubleshooting/#missing-workflow-file","text":"When it says gitStream.cm Skipped \u2014 gitStream workflow file not found , it means that the GitHub action was not found, check again that you have this file in your repository root: .github/workflows/gitstream.yml , see instructions on GitHub installation .","title":"Missing workflow file"},{"location":"troubleshooting/#syntax-error-in-the-cm-files","text":"Clicking the Details button will show more information and context. You can add this automation to see details on context variable.","title":"Syntax error in the cm files"},{"location":"troubleshooting/#how-can-i-debug-expressions-and-see-their-content","text":"You can dump any context value to the PR comment. For example, to see the list of changed files, use: automations : show_changed_files : if : - true run : - action : add-comment@v1 args : comment : | FILES DUMP {{ files | dump | safe }} JS FILES DUMP {{ files | filter ( regex = r / \\ .js $ /) | dump | safe }} Download and add to your repo .cm directory","title":"How can I debug expressions and see their content?"},{"location":"troubleshooting/#gitstream-fails-with-syntax-error-after-adding-new-rules","text":"IntelliJ IDEA has automatic code styling for YAML that can break the .cm syntax, check the following Settings/Preferences | Editor | Code Style | YAML --> Spaces | Code braces and make sure it is unchecked. VS Code YAML plugin by Red Hat extension [vscode-yaml](https://github.com/redhat-developer/vscode-yaml) has automatic code styling for YAML that can break the .cm syntax, make sure you disable bracketSpacing { \"yaml.format.bracketSpacing\" : false , }","title":"gitStream fails with syntax error after adding new rules"},{"location":"troubleshooting/#not-here","text":"Create a new issue in the project's issues","title":"Not here?"},{"location":"automations/automation-library/","text":"gitStream Automation Library This library of gitStream examples is meant to serve as a starting point for your automation. We encourage you to customize them for your project and organization. If you're looking for examples of how to integrate gitStream with other tools, take a look at the integrations page How to use these examples. These examples are all complete gitStream configuration files that you can download directly via the buttons below the examples and upload to the .cm directory of your repo. Alternatively, you can copy and paste the individual automations, but make sure you include all required declarations and any related custom expressions from the configurations to ensure they work properly. Improve PR Efficiency These examples focus on auto-approve policies and providing detailed context via labels. Auto-Approve Merges Approve safe changes - Approve documentation, formatting changes, and tests. Approve tests - Label and approve PRs that only include tests. Approve Tiny Changes - Approve single-line changes to a single file. Approve JavaScript formatting - Approve non-functional changes to JavaScript files Approve JavaScript log output - Approve changes to JavaScript files that only affect log output. Approve Python formatting - Approve non-functional changes to Python files Approve Python log output - Approve changes to Python files that only affect log output. Approve team by directory - Approve PRs from specific teams to specified directories and files . Add PR Context With Labels Provide estimated time to review - Label all PRs with an estimated number of minutes it would take someone to review. Label PRs without tests - Apply a missing-tests label to any PRs that lack updates to tests. Welcome newcomer - Post a welcome message when someone makes their first PR to a repo, and provide context to help them know what's next. Label percent new code - Post a comment that indicates what percentage of the PR contains new code. Label deleted files - Label PRs that delete files. Request screenshot - Request a screenshot in the PR description if none exist. Improve PR Quality These examples help you identify code experts and assign reviewers based on the contents of the PR. Merge Routing Additional review for large PRs - Require additional reviewers for complex PRs. Assign code experts - Identify the best experts for a PR and assign them to review. Assign reviewers by directory - Automatically assign code reviewers based on directory structure. Change missing Lambda field - Request changes if a PR creates a new Lambda function that lacks a required field. Close wrong team by directory - Close PRs to a specified directory if the PR author is not on an approved team. Security Policy Compliance These examples help you follow your team's security best practices. Review sensitive files - Define a custom list of files and directories that trigger additional reviews. Change deprecated components - Request changes when a PR includes one or more deprecated components. Contribute Your Idea Have a great idea for an automation that should be included in this library? Submit your configuration on GitHub. We'll recognize your contribution publicly (if you want) and might even send you some special swag for your contribution. /:\\","title":"Automation Library"},{"location":"automations/automation-library/#gitstream-automation-library","text":"This library of gitStream examples is meant to serve as a starting point for your automation. We encourage you to customize them for your project and organization. If you're looking for examples of how to integrate gitStream with other tools, take a look at the integrations page How to use these examples. These examples are all complete gitStream configuration files that you can download directly via the buttons below the examples and upload to the .cm directory of your repo. Alternatively, you can copy and paste the individual automations, but make sure you include all required declarations and any related custom expressions from the configurations to ensure they work properly.","title":"gitStream Automation Library"},{"location":"automations/automation-library/#improve-pr-efficiency","text":"These examples focus on auto-approve policies and providing detailed context via labels.","title":"Improve PR Efficiency"},{"location":"automations/automation-library/#auto-approve-merges","text":"Approve safe changes - Approve documentation, formatting changes, and tests. Approve tests - Label and approve PRs that only include tests. Approve Tiny Changes - Approve single-line changes to a single file. Approve JavaScript formatting - Approve non-functional changes to JavaScript files Approve JavaScript log output - Approve changes to JavaScript files that only affect log output. Approve Python formatting - Approve non-functional changes to Python files Approve Python log output - Approve changes to Python files that only affect log output. Approve team by directory - Approve PRs from specific teams to specified directories and files .","title":"Auto-Approve Merges"},{"location":"automations/automation-library/#add-pr-context-with-labels","text":"Provide estimated time to review - Label all PRs with an estimated number of minutes it would take someone to review. Label PRs without tests - Apply a missing-tests label to any PRs that lack updates to tests. Welcome newcomer - Post a welcome message when someone makes their first PR to a repo, and provide context to help them know what's next. Label percent new code - Post a comment that indicates what percentage of the PR contains new code. Label deleted files - Label PRs that delete files. Request screenshot - Request a screenshot in the PR description if none exist.","title":"Add PR Context With Labels"},{"location":"automations/automation-library/#improve-pr-quality","text":"These examples help you identify code experts and assign reviewers based on the contents of the PR.","title":"Improve PR Quality"},{"location":"automations/automation-library/#merge-routing","text":"Additional review for large PRs - Require additional reviewers for complex PRs. Assign code experts - Identify the best experts for a PR and assign them to review. Assign reviewers by directory - Automatically assign code reviewers based on directory structure. Change missing Lambda field - Request changes if a PR creates a new Lambda function that lacks a required field. Close wrong team by directory - Close PRs to a specified directory if the PR author is not on an approved team.","title":"Merge Routing"},{"location":"automations/automation-library/#security-policy-compliance","text":"These examples help you follow your team's security best practices. Review sensitive files - Define a custom list of files and directories that trigger additional reviews. Change deprecated components - Request changes when a PR includes one or more deprecated components.","title":"Security Policy Compliance"},{"location":"automations/automation-library/#contribute-your-idea","text":"Have a great idea for an automation that should be included in this library? Submit your configuration on GitHub. We'll recognize your contribution publicly (if you want) and might even send you some special swag for your contribution.","title":"Contribute Your Idea"},{"location":"automations/automation-template/","text":"Automation Name Short description Conditions (all must be true): Condition 1 Automation Actions: Action 1 Automation Name Download this example as a CM file.","title":"Automation Name"},{"location":"automations/automation-template/#automation-name","text":"Short description Conditions (all must be true): Condition 1 Automation Actions: Action 1 Automation Name Download this example as a CM file.","title":"Automation Name"},{"location":"automations/additional-review-for-large-pr/","text":"Additional Review for Large PRs Require 2 reviewers for PRs that have more than 10 changed files in the src directory and the estimated time to review is 30 or more minutes. Conditions (all must be true): There are 10 or more changed files The estimated time to review is 30 minutes or more. One or more of the changed files is inside the src directory. Automation Actions: Require a minumim of 2 reviews. Post a comment that explains this is considered a large change that requires 2 reviews. Additional Review for Large PRs # -*- mode: yaml -*- manifest : version : 1.0 automations : additional_review_for_large_pr : if : - {{ branch | estimatedReviewTime >= 30 }} - {{ files | length >= 10 }} - {{ files | match ( regex = r / src \\ //) | some }} run : - action : set-required-approvals@v1 args : approvals : 2 - action : add-comment@v1 args : comment : | This PR is a large change and requires 2 reviews. Download this example as a CM file.","title":"Additional Review for Large PRs"},{"location":"automations/additional-review-for-large-pr/#additional-review-for-large-prs","text":"Require 2 reviewers for PRs that have more than 10 changed files in the src directory and the estimated time to review is 30 or more minutes. Conditions (all must be true): There are 10 or more changed files The estimated time to review is 30 minutes or more. One or more of the changed files is inside the src directory. Automation Actions: Require a minumim of 2 reviews. Post a comment that explains this is considered a large change that requires 2 reviews. Additional Review for Large PRs # -*- mode: yaml -*- manifest : version : 1.0 automations : additional_review_for_large_pr : if : - {{ branch | estimatedReviewTime >= 30 }} - {{ files | length >= 10 }} - {{ files | match ( regex = r / src \\ //) | some }} run : - action : set-required-approvals@v1 args : approvals : 2 - action : add-comment@v1 args : comment : | This PR is a large change and requires 2 reviews. Download this example as a CM file.","title":"Additional Review for Large PRs"},{"location":"automations/approve-javascript-formatting-change/","text":"Approve JavaScript Formatting Changes Approve PRs that only contain formatting changes to JavaScript or TypeScript files. Conditions (all must be true): All of the files end in .js or .ts All changes are non-functional Automation Actions: Approve the PR Apply a code-formatting label. Post a comment that explains the automation. Approve JavaScript Formatting Change # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_javascript_formatting : if : - {{ files | extensions | match ( list =[ 'js' , 'ts' ]) | every }} - {{ source.diff.files | isFormattingChange }} run : - action : approve@v1 - action : add-label@v1 args : label : code-formatting - action : add-comment@v1 args : comment : | This PR only contains formatting changes and has been approved. Download this example as a CM file.","title":"Approve JavaScript Formatting Changes"},{"location":"automations/approve-javascript-formatting-change/#approve-javascript-formatting-changes","text":"Approve PRs that only contain formatting changes to JavaScript or TypeScript files. Conditions (all must be true): All of the files end in .js or .ts All changes are non-functional Automation Actions: Approve the PR Apply a code-formatting label. Post a comment that explains the automation. Approve JavaScript Formatting Change # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_javascript_formatting : if : - {{ files | extensions | match ( list =[ 'js' , 'ts' ]) | every }} - {{ source.diff.files | isFormattingChange }} run : - action : approve@v1 - action : add-label@v1 args : label : code-formatting - action : add-comment@v1 args : comment : | This PR only contains formatting changes and has been approved. Download this example as a CM file.","title":"Approve JavaScript Formatting Changes"},{"location":"automations/approve-javascript-log-output/","text":"Approve JavaScript Log Output Changes Approve changes to JavaScript files that only affect lines of code that invoke the console.log() method. Conditions (all must be true): All files must end in .js or .ts The changes only affect lines of code that invoke console.log() Automation Actions: Applies a log-output-only label Approves the PR Posts a comment explaining that the change only affects logging output. Approve JavaScript Log Output Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_javascript_log_output : # Triggered for JavaScript changes that only affect the console.log() method if : - {{ files | match ( regex = r / \\ .js $|\\ .ts $ /) | every }} - {{ source.diff.files | matchDiffLines ( regex = r / ^ [+-] . * console \\ .log /, ignoreWhiteSpaces = true ) | every }} run : - action : add-label@v1 args : label : 'log-output-only' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR has been approved because it only contains changes to log output Download this example as a CM file.","title":"Approve JavaScript Log Output Changes"},{"location":"automations/approve-javascript-log-output/#approve-javascript-log-output-changes","text":"Approve changes to JavaScript files that only affect lines of code that invoke the console.log() method. Conditions (all must be true): All files must end in .js or .ts The changes only affect lines of code that invoke console.log() Automation Actions: Applies a log-output-only label Approves the PR Posts a comment explaining that the change only affects logging output. Approve JavaScript Log Output Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_javascript_log_output : # Triggered for JavaScript changes that only affect the console.log() method if : - {{ files | match ( regex = r / \\ .js $|\\ .ts $ /) | every }} - {{ source.diff.files | matchDiffLines ( regex = r / ^ [+-] . * console \\ .log /, ignoreWhiteSpaces = true ) | every }} run : - action : add-label@v1 args : label : 'log-output-only' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR has been approved because it only contains changes to log output Download this example as a CM file.","title":"Approve JavaScript Log Output Changes"},{"location":"automations/approve-python-formatting-change/","text":"Approve Python Formatting Changes Approve PRs that only contain formatting changes to Python files. Conditions (all must be true): All of the files end in .py . All changes are non-functional Automation Actions: Approve the PR Apply a code-formatting label. Post a comment that explains the automation. Approve Python Formatting Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_python_formatting : if : - {{ files | extensions | match ( list =[ 'py' ]) | every }} - {{ source.diff.files | isFormattingChange }} run : - action : approve@v1 - action : add-label@v1 args : label : code-formatting - action : add-comment@v1 args : comment : | This PR only contains formatting changes and has been approved. Download this example as a CM file.","title":"Approve Python Formatting Changes"},{"location":"automations/approve-python-formatting-change/#approve-python-formatting-changes","text":"Approve PRs that only contain formatting changes to Python files. Conditions (all must be true): All of the files end in .py . All changes are non-functional Automation Actions: Approve the PR Apply a code-formatting label. Post a comment that explains the automation. Approve Python Formatting Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_python_formatting : if : - {{ files | extensions | match ( list =[ 'py' ]) | every }} - {{ source.diff.files | isFormattingChange }} run : - action : approve@v1 - action : add-label@v1 args : label : code-formatting - action : add-comment@v1 args : comment : | This PR only contains formatting changes and has been approved. Download this example as a CM file.","title":"Approve Python Formatting Changes"},{"location":"automations/approve-python-log-output/","text":"Approve Python Log Output Changes Approve changes to Python files that only affect lines of code that invoke a specified logging object. Conditions (all must be true): All files must end in .py The changes only affect lines of code that invoke a logger object. This should be customized to your environment. Automation Actions: Applies a log-output-only label Approves the PR Posts a comment explaining that the change only affects logging output. Approve Python Log Output Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_python_log_output : # Triggered for python changes that only affect lines of code that invoke a logger object. # Modify 'logger' to match your dev environment. if : - {{ files | match ( regex = r / \\ .py $ /) | every }} - {{ source.diff.files | matchDiffLines ( regex = r / ^ [+-] . * logger \\. ( trace | debug | info | warn | error )/, ignoreWhiteSpaces = true ) | every }} run : - action : add-label@v1 args : label : 'log-output-only' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR has been approved because it only contains changes to log output Download this example as a CM file.","title":"Approve Python Log Output Changes"},{"location":"automations/approve-python-log-output/#approve-python-log-output-changes","text":"Approve changes to Python files that only affect lines of code that invoke a specified logging object. Conditions (all must be true): All files must end in .py The changes only affect lines of code that invoke a logger object. This should be customized to your environment. Automation Actions: Applies a log-output-only label Approves the PR Posts a comment explaining that the change only affects logging output. Approve Python Log Output Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_python_log_output : # Triggered for python changes that only affect lines of code that invoke a logger object. # Modify 'logger' to match your dev environment. if : - {{ files | match ( regex = r / \\ .py $ /) | every }} - {{ source.diff.files | matchDiffLines ( regex = r / ^ [+-] . * logger \\. ( trace | debug | info | warn | error )/, ignoreWhiteSpaces = true ) | every }} run : - action : add-label@v1 args : label : 'log-output-only' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR has been approved because it only contains changes to log output Download this example as a CM file.","title":"Approve Python Log Output Changes"},{"location":"automations/approve-safe-changes/","text":"Approve Safe Changes If the PR content only contains one or more of documentation, formatting changes, or tests, automatically approve the PR and apply a safe change label. Conditions (all must be true): The PR only contains documentation, tests, or formatting changes. Automation Actions: Add a safe-change label Approve the PR Post a comment that explains that this is a safe change Approve Safe Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : safe_changes : # Triggered for any changes that only affect formatting, documentation, tests, or images if : - {{ is .formatting or is .docs or is .tests or is .image }} # Apply a safe change label, approve the PR and explain why in a comment. run : - action : add-label@v1 args : label : 'safe-change' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR is considered a safe change and has been automatically approved. # These custom expressions are used in the safe_changes automation is : formatting : {{ source.diff.files | isFormattingChange }} docs : {{ files | allDocs }} tests : {{ files | allTests }} image : {{ files | allImages }} Download this example as a CM file.","title":"Approve Safe Changes"},{"location":"automations/approve-safe-changes/#approve-safe-changes","text":"If the PR content only contains one or more of documentation, formatting changes, or tests, automatically approve the PR and apply a safe change label. Conditions (all must be true): The PR only contains documentation, tests, or formatting changes. Automation Actions: Add a safe-change label Approve the PR Post a comment that explains that this is a safe change Approve Safe Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : safe_changes : # Triggered for any changes that only affect formatting, documentation, tests, or images if : - {{ is .formatting or is .docs or is .tests or is .image }} # Apply a safe change label, approve the PR and explain why in a comment. run : - action : add-label@v1 args : label : 'safe-change' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR is considered a safe change and has been automatically approved. # These custom expressions are used in the safe_changes automation is : formatting : {{ source.diff.files | isFormattingChange }} docs : {{ files | allDocs }} tests : {{ files | allTests }} image : {{ files | allImages }} Download this example as a CM file.","title":"Approve Safe Changes"},{"location":"automations/approve-swimm/","text":"This file has moved: /docs/automations/integrations/swimm/approve-swimm","title":"Index"},{"location":"automations/approve-team-by-directory/","text":"Approve Expert Team Approve PRs to a specified directory from a specific team. Conditions (all must be true): All changed files are inside the docs directory The PR author is on the tech-writers team. Automation Actions: Approve the PR Post a comment that explains the approval. Approve Expert Team # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_team_by_directory : # Triggered for PRs that only include changes to files inside the docs directory, # and that are authored by someone on the tech-writers team. if : - {{ files | match ( regex = r / docs \\ //) | every }} - {{ pr.author_teams | match ( term = 'tech-writers' ) }} run : - action : approve@v1 - action : add-comment@v1 args : comment : | Docs changes from the tech-writers team are automatically approved. Download this example as a CM file.","title":"Approve Expert Team"},{"location":"automations/approve-team-by-directory/#approve-expert-team","text":"Approve PRs to a specified directory from a specific team. Conditions (all must be true): All changed files are inside the docs directory The PR author is on the tech-writers team. Automation Actions: Approve the PR Post a comment that explains the approval. Approve Expert Team # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_team_by_directory : # Triggered for PRs that only include changes to files inside the docs directory, # and that are authored by someone on the tech-writers team. if : - {{ files | match ( regex = r / docs \\ //) | every }} - {{ pr.author_teams | match ( term = 'tech-writers' ) }} run : - action : approve@v1 - action : add-comment@v1 args : comment : | Docs changes from the tech-writers team are automatically approved. Download this example as a CM file.","title":"Approve Expert Team"},{"location":"automations/approve-tests/","text":"Approve test changes Label and approve PRs that only include tests, and post an explanation comment. Conditions (all must be true): The PR only contains changes to tests Automation Actions: Add a tests-only label Approve the PR Post a comment that explains why the PR was approved. Approve Tests # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_tests : if : # Triggered for PRs that only include changes to tests - {{ files | allTests }} run : - action : add-label@v1 args : label : 'tests-only' - action : add-comment@v1 args : comment : | This merge has been automatically approved because it only contains changes to tests. - action : approve@v1 Download this example as a CM file.","title":"Approve test changes"},{"location":"automations/approve-tests/#approve-test-changes","text":"Label and approve PRs that only include tests, and post an explanation comment. Conditions (all must be true): The PR only contains changes to tests Automation Actions: Add a tests-only label Approve the PR Post a comment that explains why the PR was approved. Approve Tests # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_tests : if : # Triggered for PRs that only include changes to tests - {{ files | allTests }} run : - action : add-label@v1 args : label : 'tests-only' - action : add-comment@v1 args : comment : | This merge has been automatically approved because it only contains changes to tests. - action : approve@v1 Download this example as a CM file.","title":"Approve test changes"},{"location":"automations/approve-tiny-changes/","text":"Approve Tiny Changes Approve single-line changes to a single file. Conditions (all must be true): If the PR contains a one-line change to a single file. Automation Actions: Apply a single-line label. Approve the PR. Post a comment explaining why the PR was approved. name # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_tiny_change : # Triggered for PRs that contain one file and one line. if : - {{ is .one_file and is .one_line }} run : - action : add-label@v1 args : label : 'single-line' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR has been approved because it is only a single line changes : # Sum all the lines added in the PR additions : {{ branch.diff.files_metadata | map ( attr = 'additions' ) | sum }} # Sum all the line removed in the PR deletions : {{ branch.diff.files_metadata | map ( attr = 'deletions' ) | sum }} is : one_file : {{ files | length == 1 }} one_line : {{ changes.additions - changes.deletions <= 1 }} Download this example as a CM file.","title":"Approve Tiny Changes"},{"location":"automations/approve-tiny-changes/#approve-tiny-changes","text":"Approve single-line changes to a single file. Conditions (all must be true): If the PR contains a one-line change to a single file. Automation Actions: Apply a single-line label. Approve the PR. Post a comment explaining why the PR was approved. name # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_tiny_change : # Triggered for PRs that contain one file and one line. if : - {{ is .one_file and is .one_line }} run : - action : add-label@v1 args : label : 'single-line' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR has been approved because it is only a single line changes : # Sum all the lines added in the PR additions : {{ branch.diff.files_metadata | map ( attr = 'additions' ) | sum }} # Sum all the line removed in the PR deletions : {{ branch.diff.files_metadata | map ( attr = 'deletions' ) | sum }} is : one_file : {{ files | length == 1 }} one_line : {{ changes.additions - changes.deletions <= 1 }} Download this example as a CM file.","title":"Approve Tiny Changes"},{"location":"automations/assign-code-experts/","text":"Assign Code Experts When someone applies a suggest-reviewers label to a PR, use codeExperts to assign recommended reviewers and post a comment with the explainCodeExperts automation action. Conditions (all must be true): The PR has a suggest-reviewers label attached to it. Automation Actions: Use codeExperts to assign recommended reviewers. Use explainCodeExperts to post a comment that lists the top code experts for the PR. Assign Code Experts # -*- mode: yaml -*- manifest : version : 1.0 automations : assign_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Download this example as a CM file.","title":"Assign Code Experts"},{"location":"automations/assign-code-experts/#assign-code-experts","text":"When someone applies a suggest-reviewers label to a PR, use codeExperts to assign recommended reviewers and post a comment with the explainCodeExperts automation action. Conditions (all must be true): The PR has a suggest-reviewers label attached to it. Automation Actions: Use codeExperts to assign recommended reviewers. Use explainCodeExperts to post a comment that lists the top code experts for the PR. Assign Code Experts # -*- mode: yaml -*- manifest : version : 1.0 automations : assign_code_experts : # Triggered when someone applies a suggest-reviewer label to a PR. if : - {{ pr.labels | match ( term = 'suggest-reviewer' ) }} # Identify the best experts to assign for review and post a comment that explains why # More info about code experts # https://docs.gitstream.cm/filter-functions/#codeexperts run : - action : add-reviewers@v1 args : reviewers : {{ repo | codeExperts ( gt = 10 ) }} - action : add-comment@v1 args : comment : | {{ repo | explainCodeExperts ( gt = 10 ) }} Download this example as a CM file.","title":"Assign Code Experts"},{"location":"automations/assign-reviewers-by-directory/","text":"Assign Reviewers by Directory Automatically assign code reviewers based on directory structure. Optionally, you can substitue require-reviewers for add-reviewers to make review from the specified teams and individuals mandatory. Conditions (all must be true): The PR contains changes to JavaScript files inside the src/ui directory. Automation Actions: Add a user named my-teamate and a team named my-organization/ui-team as reviewers. These should be customized to match your organization. Post a comment explaining why these reviewers were assigned. Assign Reviewers by Directory # -*- mode: yaml -*- manifest : version : 1.0 automations : review_ui : # Triggered for PRs that contain any changes to JavaScript files inside the `src/ui` directory. if : - {{ files | match ( regex = r / src \\ / app \\ / auth \\ / . */) | some }} # Add a specified user and team as reviewers. # Customize the reviewers to match your organization run : - action : add-reviewers@v1 args : reviewers : [ my-teamate , my-organization/security ] - action : add-comment@v1 args : comment : | The Security team has automatically been added for review because this PR contains changes to components inside `/src/app/auth` Download this example as a CM file.","title":"Assign Reviewers by Directory"},{"location":"automations/assign-reviewers-by-directory/#assign-reviewers-by-directory","text":"Automatically assign code reviewers based on directory structure. Optionally, you can substitue require-reviewers for add-reviewers to make review from the specified teams and individuals mandatory. Conditions (all must be true): The PR contains changes to JavaScript files inside the src/ui directory. Automation Actions: Add a user named my-teamate and a team named my-organization/ui-team as reviewers. These should be customized to match your organization. Post a comment explaining why these reviewers were assigned. Assign Reviewers by Directory # -*- mode: yaml -*- manifest : version : 1.0 automations : review_ui : # Triggered for PRs that contain any changes to JavaScript files inside the `src/ui` directory. if : - {{ files | match ( regex = r / src \\ / app \\ / auth \\ / . */) | some }} # Add a specified user and team as reviewers. # Customize the reviewers to match your organization run : - action : add-reviewers@v1 args : reviewers : [ my-teamate , my-organization/security ] - action : add-comment@v1 args : comment : | The Security team has automatically been added for review because this PR contains changes to components inside `/src/app/auth` Download this example as a CM file.","title":"Assign Reviewers by Directory"},{"location":"automations/assign-team-members-as-reviewers/","text":"Assign team members as reviewers Assign PR reviewer based on the owner team membership. You can also omit the | first filter to assign all teams the owner is member of. name Download this example as a CM file.","title":"Assign team members as reviewers"},{"location":"automations/assign-team-members-as-reviewers/#assign-team-members-as-reviewers","text":"Assign PR reviewer based on the owner team membership. You can also omit the | first filter to assign all teams the owner is member of. name Download this example as a CM file.","title":"Assign team members as reviewers"},{"location":"automations/change-deprecated-components/","text":"Change Deprecated Components Request changes when a PR includes one or more deprecated components. Conditions (all must be true): A PR contains one or more references to functions, methods, or classes that have been designated as deprecated. Automation Actions: Add a deprecated-component label to the PR Request changes to the PR and post a comment that explains what deprecated component was included and what the alternative is. Change Deprecated Components # -*- mode: yaml -*- manifest : version : 1.0 automations : # Request changes when a PR includes deprecated components. # This requires the `item` custom expression found at the bottom of this file. {% for item in deprecated %} # Automation names must be unique, so this adds an iterator index to each instance catch_deprecated_components_ {{ loop .index }} : # Triggered when any of the modified files use a deprecated component if : - {{ source.diff.files | matchDiffLines ( regex = item.regex ) | some }} # Apply a deprecated-component label, request changes, and post a comment with an explanation. run : - action : add-label@v1 args : label : 'deprecated-component' color : '#FF0000' - action : request-changes@v1 args : comment : | ` {{ item.old }} ` component is deprecated, use ` {{ item.new }} ` instead {% endfor %} # These are the deprecated files that are evaluated in catch_deprecated_components deprecated : - regex : r/oldAPI/ old : oldAPI new : newAPI - regex : r/anotherOldAPI/ old : anotherOldAPI new : anotherNewAPI Download this example as a CM file.","title":"Change Deprecated Components"},{"location":"automations/change-deprecated-components/#change-deprecated-components","text":"Request changes when a PR includes one or more deprecated components. Conditions (all must be true): A PR contains one or more references to functions, methods, or classes that have been designated as deprecated. Automation Actions: Add a deprecated-component label to the PR Request changes to the PR and post a comment that explains what deprecated component was included and what the alternative is. Change Deprecated Components # -*- mode: yaml -*- manifest : version : 1.0 automations : # Request changes when a PR includes deprecated components. # This requires the `item` custom expression found at the bottom of this file. {% for item in deprecated %} # Automation names must be unique, so this adds an iterator index to each instance catch_deprecated_components_ {{ loop .index }} : # Triggered when any of the modified files use a deprecated component if : - {{ source.diff.files | matchDiffLines ( regex = item.regex ) | some }} # Apply a deprecated-component label, request changes, and post a comment with an explanation. run : - action : add-label@v1 args : label : 'deprecated-component' color : '#FF0000' - action : request-changes@v1 args : comment : | ` {{ item.old }} ` component is deprecated, use ` {{ item.new }} ` instead {% endfor %} # These are the deprecated files that are evaluated in catch_deprecated_components deprecated : - regex : r/oldAPI/ old : oldAPI new : newAPI - regex : r/anotherOldAPI/ old : anotherOldAPI new : anotherNewAPI Download this example as a CM file.","title":"Change Deprecated Components"},{"location":"automations/change-missing-lambda-field/","text":"Change Missing Lambda Field If a PR creates a new Lambda function, but lacks a description field, gitStream will request changes and post a comment that explains why. Conditions (all must be true): The PR contains an update to a Lambda function. The affected files are missing a description field. Automation Actions: Add a lambda-missing-field label to the PR. Request changes and post a comment that explains why. Change Missing Lambda Field # -*- mode: yaml -*- manifest : version : 1.0 automations : # Request changes when required Lambda information is missing from the PR. catch_missing_lambda_info : # Triggered for new Lambda functions that are missing a description field. if : - {{ source.diff.files | matchDiffLines ( regex = r / LambdaFunction /) | some }} - {{ source.diff.files | matchDiffLines ( regex = r / description :/) | nope }} # Apply the lambda-missing-field label and request changes to the PR. run : - action : add-label@v1 args : label : 'lambda-missing-field' color : '#FF0000' - action : request-changes@v1 args : comment : | New `LambdaFunction` must have `description:` field. Download this example as a CM file.","title":"Change Missing Lambda Field"},{"location":"automations/change-missing-lambda-field/#change-missing-lambda-field","text":"If a PR creates a new Lambda function, but lacks a description field, gitStream will request changes and post a comment that explains why. Conditions (all must be true): The PR contains an update to a Lambda function. The affected files are missing a description field. Automation Actions: Add a lambda-missing-field label to the PR. Request changes and post a comment that explains why. Change Missing Lambda Field # -*- mode: yaml -*- manifest : version : 1.0 automations : # Request changes when required Lambda information is missing from the PR. catch_missing_lambda_info : # Triggered for new Lambda functions that are missing a description field. if : - {{ source.diff.files | matchDiffLines ( regex = r / LambdaFunction /) | some }} - {{ source.diff.files | matchDiffLines ( regex = r / description :/) | nope }} # Apply the lambda-missing-field label and request changes to the PR. run : - action : add-label@v1 args : label : 'lambda-missing-field' color : '#FF0000' - action : request-changes@v1 args : comment : | New `LambdaFunction` must have `description:` field. Download this example as a CM file.","title":"Change Missing Lambda Field"},{"location":"automations/close-wrong-team-by-directory/","text":"Close Wrong Team by Directory Close PRs to a specified directory if the PR author is not on an approved team. Conditions (all must be true): The PR changes one or more files inside /src/views . Customize this value for your project. The PR author is not a member of the ui team. Customize this value for your organization. Automation Actions: Close the PR. Post a comment that explains why the PR was closed. Close Wrong Team by Directory # -*- mode: yaml -*- manifest : version : 1.0 automations : # Close PRs to restricted sections of the codebase if the PR author isn't on the correct team. close_wrong_team_by_directory : # Triggered when someone who isn't on the `ui` team submits a PR to change files inside /src/views if : - {{ files | match ( regex = r / src \\ / views /) | some }} - {{ pr.author_teams | match ( term = 'ui' ) | nope }} # Close the PR and post a comment explaining the next step. run : - action : add-comment@v1 args : comment : Please contact a member of the `ui` team if you need to make changes to files in `src/views` - action : close@v1 Download this example as a CM file.","title":"Close Wrong Team by Directory"},{"location":"automations/close-wrong-team-by-directory/#close-wrong-team-by-directory","text":"Close PRs to a specified directory if the PR author is not on an approved team. Conditions (all must be true): The PR changes one or more files inside /src/views . Customize this value for your project. The PR author is not a member of the ui team. Customize this value for your organization. Automation Actions: Close the PR. Post a comment that explains why the PR was closed. Close Wrong Team by Directory # -*- mode: yaml -*- manifest : version : 1.0 automations : # Close PRs to restricted sections of the codebase if the PR author isn't on the correct team. close_wrong_team_by_directory : # Triggered when someone who isn't on the `ui` team submits a PR to change files inside /src/views if : - {{ files | match ( regex = r / src \\ / views /) | some }} - {{ pr.author_teams | match ( term = 'ui' ) | nope }} # Close the PR and post a comment explaining the next step. run : - action : add-comment@v1 args : comment : Please contact a member of the `ui` team if you need to make changes to files in `src/views` - action : close@v1 Download this example as a CM file.","title":"Close Wrong Team by Directory"},{"location":"automations/integrations/dependabot/approve-dependabot/","text":"Approve and Merge Dependabot Changes Approve PRs from Dependabot Conditions (all must be true): The PR author is Dependabot. The branch name includes 'dependabot' Automation Actions: Approve the PR Apply an approved-dependabot label to the PR Merge the PR if all status checks pass. Approve Dependabot # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_dependabot : if : - {{ branch.name | includes ( term = \"dependabot\" ) }} - {{ branch.author | includes ( term = \"dependabot\" ) }} run : - action : approve@v1 - action : add-label@v1 args : label : \"approved-dependabot\" - action : merge@v1 args : wait_for_all_checks : true squash_on_merge : true Download this example as a CM file.","title":"Approve and Merge Dependabot Changes"},{"location":"automations/integrations/dependabot/approve-dependabot/#approve-and-merge-dependabot-changes","text":"Approve PRs from Dependabot Conditions (all must be true): The PR author is Dependabot. The branch name includes 'dependabot' Automation Actions: Approve the PR Apply an approved-dependabot label to the PR Merge the PR if all status checks pass. Approve Dependabot # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_dependabot : if : - {{ branch.name | includes ( term = \"dependabot\" ) }} - {{ branch.author | includes ( term = \"dependabot\" ) }} run : - action : approve@v1 - action : add-label@v1 args : label : \"approved-dependabot\" - action : merge@v1 args : wait_for_all_checks : true squash_on_merge : true Download this example as a CM file.","title":"Approve and Merge Dependabot Changes"},{"location":"automations/integrations/jira/label-missing-jira-info/","text":"Label Missing Jira Info Label PRs that don't reference a Jira ticket in the title or description. This uses regex to detect Jira ticket formats in the title (e.g. ABC-1234), and URLs to Jira tickets in the description. Conditions (all must be true): The PR lacks a Jira ticket number in the title, or a link to a Jira ticket in the PR description. Automation Actions: Apply a missing-jira label. Label Missing Jira Info # -*- mode: yaml -*- manifest : version : 1.0 automations : label_missing_jira_info : # Triggered for PRs that don't have either a Jira ticket number in the title, # or a link to a Jira ticket in the PR description. if : - {{ not ( has.jira_ticket_in_title or has.jira_ticket_in_desc ) }} run : - action : add-label@v1 args : label : \"missing-jira\" color : 'F6443B' has : jira_ticket_in_title : {{ pr.title | includes ( regex = r / ^\\ [ ?\\ w { 3 , 4 }- \\ d { 1 , 6 } \\ ] ? ( \\ s | -| _ ) . { 1 ,} $ /) }} jira_ticket_in_desc : {{ pr.description | includes ( regex = r / atlassian.net \\ / browse \\ / \\ w { 1 ,}- \\ d { 3 , 4 }/) }} Download this example as a CM file.","title":"Label Missing Jira Info"},{"location":"automations/integrations/jira/label-missing-jira-info/#label-missing-jira-info","text":"Label PRs that don't reference a Jira ticket in the title or description. This uses regex to detect Jira ticket formats in the title (e.g. ABC-1234), and URLs to Jira tickets in the description. Conditions (all must be true): The PR lacks a Jira ticket number in the title, or a link to a Jira ticket in the PR description. Automation Actions: Apply a missing-jira label. Label Missing Jira Info # -*- mode: yaml -*- manifest : version : 1.0 automations : label_missing_jira_info : # Triggered for PRs that don't have either a Jira ticket number in the title, # or a link to a Jira ticket in the PR description. if : - {{ not ( has.jira_ticket_in_title or has.jira_ticket_in_desc ) }} run : - action : add-label@v1 args : label : \"missing-jira\" color : 'F6443B' has : jira_ticket_in_title : {{ pr.title | includes ( regex = r / ^\\ [ ?\\ w { 3 , 4 }- \\ d { 1 , 6 } \\ ] ? ( \\ s | -| _ ) . { 1 ,} $ /) }} jira_ticket_in_desc : {{ pr.description | includes ( regex = r / atlassian.net \\ / browse \\ / \\ w { 1 ,}- \\ d { 3 , 4 }/) }} Download this example as a CM file.","title":"Label Missing Jira Info"},{"location":"automations/integrations/sonar/approve-sonar-clean-code/","text":"Approve Sonar Clean Code Approve PRs that pass SonarCloud's quality gate. Conditions (all must be true): SonarCloud reports an 'A' rating for vulnerabilities, bugs, security hotspots, and code smells. There is no duplicated code. Automation Actions: Apply a Sonar: Clean Code label to the PR. Approve the PR. Post a comment that explains why the PR was approved. Aprove Sonar Clean Code # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_sonar_clean_code : if : - {{ sonar.bugs.rating == 'A' }} - {{ sonar.code_smells.rating == 'A' }} - {{ sonar.vulnerabilities.rating == 'A' }} - {{ sonar.security_hotspots.rating == 'A' }} - {{ sonar.duplications == null or sonar.duplications == 0 }} run : - action : add-label@v1 args : label : '\u2705 Sonar: Clean Code' color : {{ colors.green }} - action : approve@v1 - action : add-comment@v1 args : comment : | This PR passes the SonarCloud quality gate check and as been automatically approved. sonar : {{ pr | extractSonarFindings }} colors : green : '0e8a16' Download this example as a CM file.","title":"Approve Sonar Clean Code"},{"location":"automations/integrations/sonar/approve-sonar-clean-code/#approve-sonar-clean-code","text":"Approve PRs that pass SonarCloud's quality gate. Conditions (all must be true): SonarCloud reports an 'A' rating for vulnerabilities, bugs, security hotspots, and code smells. There is no duplicated code. Automation Actions: Apply a Sonar: Clean Code label to the PR. Approve the PR. Post a comment that explains why the PR was approved. Aprove Sonar Clean Code # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_sonar_clean_code : if : - {{ sonar.bugs.rating == 'A' }} - {{ sonar.code_smells.rating == 'A' }} - {{ sonar.vulnerabilities.rating == 'A' }} - {{ sonar.security_hotspots.rating == 'A' }} - {{ sonar.duplications == null or sonar.duplications == 0 }} run : - action : add-label@v1 args : label : '\u2705 Sonar: Clean Code' color : {{ colors.green }} - action : approve@v1 - action : add-comment@v1 args : comment : | This PR passes the SonarCloud quality gate check and as been automatically approved. sonar : {{ pr | extractSonarFindings }} colors : green : '0e8a16' Download this example as a CM file.","title":"Approve Sonar Clean Code"},{"location":"automations/integrations/sonar/label-sonar/","text":"Label SonarCloud Quality Reports Label the number of bugs, vulnerabilities, security hotspots, and code smells reported by SonarCloud. Conditions (all must be true): There is at least one vulnerability, code smell, security hotspot, or bug reported by SonarCloud. Uses the extractSonarFindings filter function Automation Actions: Apply color-coded labels to indicate the number of vulnerabilities, code smells, security hotspots, and bugs. Label SonarCloud Quality Reports # -*- mode: yaml -*- manifest : version : 1.0 automations : {% for item in reports %} label_sonar_ {{ item.name }} : if : - {{ item.count > 0 }} run : - action : add-label@v1 args : label : ' {{ item.icon }} x {{ item.count }} {{ item.name }} ' color : {{ colors.red if ( item.rating == 'E' or item.rating == 'D' ) else ( colors.orange if ( item.rating == 'C' ) else colors.yellow ) }} {% endfor %} sonar : {{ pr | extractSonarFindings }} reports : - name : vulnerabilities count : {{ sonar.vulnerabilities.count }} icon : \ud83d\udd13 rating : {{ sonar.vulnerabilities.rating }} - name : code smells count : {{ sonar.code_smells.count }} icon : \u2623\ufe0f rating : {{ sonar.code_smells.rating }} - name : security hotspots count : {{ sonar.security_hotspots.count }} icon : \ud83d\udee1\ufe0f rating : {{ sonar.security_hotspots.rating }} - name : bugs count : {{ sonar.bugs.count }} icon : \ud83e\udeb2 rating : {{ sonar.bugs.rating }} colors : red : 'b60205' orange : 'd93f0b' yellow : 'fbca04' Download this example as a CM file.","title":"Label SonarCloud Quality Reports"},{"location":"automations/integrations/sonar/label-sonar/#label-sonarcloud-quality-reports","text":"Label the number of bugs, vulnerabilities, security hotspots, and code smells reported by SonarCloud. Conditions (all must be true): There is at least one vulnerability, code smell, security hotspot, or bug reported by SonarCloud. Uses the extractSonarFindings filter function Automation Actions: Apply color-coded labels to indicate the number of vulnerabilities, code smells, security hotspots, and bugs. Label SonarCloud Quality Reports # -*- mode: yaml -*- manifest : version : 1.0 automations : {% for item in reports %} label_sonar_ {{ item.name }} : if : - {{ item.count > 0 }} run : - action : add-label@v1 args : label : ' {{ item.icon }} x {{ item.count }} {{ item.name }} ' color : {{ colors.red if ( item.rating == 'E' or item.rating == 'D' ) else ( colors.orange if ( item.rating == 'C' ) else colors.yellow ) }} {% endfor %} sonar : {{ pr | extractSonarFindings }} reports : - name : vulnerabilities count : {{ sonar.vulnerabilities.count }} icon : \ud83d\udd13 rating : {{ sonar.vulnerabilities.rating }} - name : code smells count : {{ sonar.code_smells.count }} icon : \u2623\ufe0f rating : {{ sonar.code_smells.rating }} - name : security hotspots count : {{ sonar.security_hotspots.count }} icon : \ud83d\udee1\ufe0f rating : {{ sonar.security_hotspots.rating }} - name : bugs count : {{ sonar.bugs.count }} icon : \ud83e\udeb2 rating : {{ sonar.bugs.rating }} colors : red : 'b60205' orange : 'd93f0b' yellow : 'fbca04' Download this example as a CM file.","title":"Label SonarCloud Quality Reports"},{"location":"automations/integrations/sonar/review-sonar-alerts/","text":"Review Sonar Security Alerts Require additional reviews for Sonar security alerts. gitStream will remove this requirement if the alerts are resolved. Conditions (all must be true): The SonarCloud quality gate check fails to pass for code smells, vulnerabilities, or security hotspots. Automation Actions: Require a review from the my-organization/security-team team. Customize this to match your organization. Post a comment explaining why this PR requires additional review. Review Sonar Alerts # -*- mode: yaml -*- manifest : version : 1.0 automations : review_sonar_alerts : if : - {{ sonar.code_smells.rating != 'A' or sonar.vulnerabilities.rating != 'A' or sonar.security_hotspots.rating != 'A' }} run : - action : require-reviewers@v1 args : reviewers : [ my-organization/security-team ] - action : add-comment@v1 args : comment : | This PR requires additional review because it fails to meet SonarCloud clean code standards. sonar : {{ pr | extractSonarFindings }} Download this example as a CM file.","title":"Review Sonar Security Alerts"},{"location":"automations/integrations/sonar/review-sonar-alerts/#review-sonar-security-alerts","text":"Require additional reviews for Sonar security alerts. gitStream will remove this requirement if the alerts are resolved. Conditions (all must be true): The SonarCloud quality gate check fails to pass for code smells, vulnerabilities, or security hotspots. Automation Actions: Require a review from the my-organization/security-team team. Customize this to match your organization. Post a comment explaining why this PR requires additional review. Review Sonar Alerts # -*- mode: yaml -*- manifest : version : 1.0 automations : review_sonar_alerts : if : - {{ sonar.code_smells.rating != 'A' or sonar.vulnerabilities.rating != 'A' or sonar.security_hotspots.rating != 'A' }} run : - action : require-reviewers@v1 args : reviewers : [ my-organization/security-team ] - action : add-comment@v1 args : comment : | This PR requires additional review because it fails to meet SonarCloud clean code standards. sonar : {{ pr | extractSonarFindings }} Download this example as a CM file.","title":"Review Sonar Security Alerts"},{"location":"automations/integrations/sonar/review-sonar-duplications/","text":"Review Sonar Duplications Request changes when Sonar reports an excessive level of duplicated code. Conditions (all must be true): The PR contains more than 3% duplicated code. Automation Actions: Apply a label that indicates how much duplicated code Sonar detected. Request changes and post a comment explaining why. Review Sonar Duplications # -*- mode: yaml -*- manifest : version : 1.0 automations : review_sonar_duplications : if : - {{ sonar.duplications > 3 }} run : - action : add-label@v1 args : label : 'Sonar: {{ sonar.duplications }} % duplication' color : {{ colors.yellow }} - action : request-changes@v1 args : comment : | Sonar reports an excessive level of code duplication. Please consider refactoring your PR to reduce duplications. sonar : {{ pr | extractSonarFindings }} colors : yellow : 'fbca04' Download this example as a CM file.","title":"Review Sonar Duplications"},{"location":"automations/integrations/sonar/review-sonar-duplications/#review-sonar-duplications","text":"Request changes when Sonar reports an excessive level of duplicated code. Conditions (all must be true): The PR contains more than 3% duplicated code. Automation Actions: Apply a label that indicates how much duplicated code Sonar detected. Request changes and post a comment explaining why. Review Sonar Duplications # -*- mode: yaml -*- manifest : version : 1.0 automations : review_sonar_duplications : if : - {{ sonar.duplications > 3 }} run : - action : add-label@v1 args : label : 'Sonar: {{ sonar.duplications }} % duplication' color : {{ colors.yellow }} - action : request-changes@v1 args : comment : | Sonar reports an excessive level of code duplication. Please consider refactoring your PR to reduce duplications. sonar : {{ pr | extractSonarFindings }} colors : yellow : 'fbca04' Download this example as a CM file.","title":"Review Sonar Duplications"},{"location":"automations/integrations/swimm/approve-swimm/","text":"Approve Swimm Changes Approve changes that only affect Swimm documentation. Conditions (all must be true): The PR only affects files that end in a .swm extension. Automation Actions: Add a swimm-docs-only label Approve the PR Post a comment that explains that this is a Swimm docs change only. Approve Swimm Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_swimm_changes : # Triggered for any changes to Swimm documentation if : - {{ files | match ( regex = r / \\ .swm \\ //) | every }} # Apply a swimm-docs-only label, approve the PR and explain why in a comment. run : - action : add-label@v1 args : label : 'swimm-docs-only' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR is considered a safe change as it only affects Swimm Docs. It has been automatically approved. Download this example as a CM file. Special thanks to Omerr for providing this example.","title":"Approve Swimm Changes"},{"location":"automations/integrations/swimm/approve-swimm/#approve-swimm-changes","text":"Approve changes that only affect Swimm documentation. Conditions (all must be true): The PR only affects files that end in a .swm extension. Automation Actions: Add a swimm-docs-only label Approve the PR Post a comment that explains that this is a Swimm docs change only. Approve Swimm Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_swimm_changes : # Triggered for any changes to Swimm documentation if : - {{ files | match ( regex = r / \\ .swm \\ //) | every }} # Apply a swimm-docs-only label, approve the PR and explain why in a comment. run : - action : add-label@v1 args : label : 'swimm-docs-only' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR is considered a safe change as it only affects Swimm Docs. It has been automatically approved. Download this example as a CM file. Special thanks to Omerr for providing this example.","title":"Approve Swimm Changes"},{"location":"automations/label-deleted-files/","text":"Label Deleted Files Label PRs that delete files. Conditions (all must be true): The PR deletes one or more files. Automation Actions: Apply a deleted-files label to the PR. Label Deleted Files # -*- mode: yaml -*- manifest : version : 1.0 automations : # Apply a label that indicates when a PR deletes files # This uses the `has` custom expression found at the bottom of this file label_deleted_files : if : - {{ has.deleted_files }} run : - action : add-label@v1 args : label : 'deleted-files' color : '#DF9C04' # This is used in the `label_deleted_files` automation has : deleted_files : {{ source.diff.files | map ( attr = 'new_file' ) | match ( term = '/dev/null' ) | some }} Download this example as a CM file.","title":"Label Deleted Files"},{"location":"automations/label-deleted-files/#label-deleted-files","text":"Label PRs that delete files. Conditions (all must be true): The PR deletes one or more files. Automation Actions: Apply a deleted-files label to the PR. Label Deleted Files # -*- mode: yaml -*- manifest : version : 1.0 automations : # Apply a label that indicates when a PR deletes files # This uses the `has` custom expression found at the bottom of this file label_deleted_files : if : - {{ has.deleted_files }} run : - action : add-label@v1 args : label : 'deleted-files' color : '#DF9C04' # This is used in the `label_deleted_files` automation has : deleted_files : {{ source.diff.files | map ( attr = 'new_file' ) | match ( term = '/dev/null' ) | some }} Download this example as a CM file.","title":"Label Deleted Files"},{"location":"automations/label-missing-jira-info/","text":"This file has moved: /docs/automations/integrations/jira/label-missing-jira-info","title":"Index"},{"location":"automations/label-prs-without-tests/","text":"Label PRs Without Tests Apply a missing-tests label to any PRs that don't update tests. gitStream will remove this label if the contributor adds a test change to the PR. Conditions (all must be true): The PR has no changes to a test. Automation Actions: Apply a missing-tests label. Label PRs Without Tests # -*- mode: yaml -*- manifest : version : 1.0 automations : label_prs_without_tests : if : - {{ files | match ( regex = r /[ ^ a-zA-Z0-9 ]( spec | test | tests )[ ^ a-zA-Z0-9 ]/) | nope }} run : - action : add-label@v1 args : label : 'missing-tests' color : '#E94637' Download this example as a CM file.","title":"Label PRs Without Tests"},{"location":"automations/label-prs-without-tests/#label-prs-without-tests","text":"Apply a missing-tests label to any PRs that don't update tests. gitStream will remove this label if the contributor adds a test change to the PR. Conditions (all must be true): The PR has no changes to a test. Automation Actions: Apply a missing-tests label. Label PRs Without Tests # -*- mode: yaml -*- manifest : version : 1.0 automations : label_prs_without_tests : if : - {{ files | match ( regex = r /[ ^ a-zA-Z0-9 ]( spec | test | tests )[ ^ a-zA-Z0-9 ]/) | nope }} run : - action : add-label@v1 args : label : 'missing-tests' color : '#E94637' Download this example as a CM file.","title":"Label PRs Without Tests"},{"location":"automations/percent-new-code/","text":"Calculate the Percentage of New Code Post a comment that indicates what percentage of the PR contains new code. Conditions (all must be true): Any PR Automation Actions: Use the changes custom expression to post a comment that indicates what percentage of the PR is new code. Calculate the Percentage of New Code # -*- mode: yaml -*- manifest : version : 1.0 automations : percent_new_code : if : - true run : - action : add-comment@v1 args : comment : | This PR is {{ changes.ratio }} % new code. changes : # Sum all the lines added/edited in the PR additions : {{ branch.diff.files_metadata | map ( attr = 'additions' ) | sum }} # Sum all the line removed in the PR deletions : {{ branch.diff.files_metadata | map ( attr = 'deletions' ) | sum }} # Calculate the ratio of new code ratio : {{ ( changes.additions / ( changes.additions + changes.deletions )) * 100 }} Download this example as a CM file.","title":"Calculate the Percentage of New Code"},{"location":"automations/percent-new-code/#calculate-the-percentage-of-new-code","text":"Post a comment that indicates what percentage of the PR contains new code. Conditions (all must be true): Any PR Automation Actions: Use the changes custom expression to post a comment that indicates what percentage of the PR is new code. Calculate the Percentage of New Code # -*- mode: yaml -*- manifest : version : 1.0 automations : percent_new_code : if : - true run : - action : add-comment@v1 args : comment : | This PR is {{ changes.ratio }} % new code. changes : # Sum all the lines added/edited in the PR additions : {{ branch.diff.files_metadata | map ( attr = 'additions' ) | sum }} # Sum all the line removed in the PR deletions : {{ branch.diff.files_metadata | map ( attr = 'deletions' ) | sum }} # Calculate the ratio of new code ratio : {{ ( changes.additions / ( changes.additions + changes.deletions )) * 100 }} Download this example as a CM file.","title":"Calculate the Percentage of New Code"},{"location":"automations/provide-estimated-time-to-review/","text":"Provide Estimated Time to Review Label all PRs with an estimated number of minutes it would take someone to review. gitStream will automatically update this label whenever a PR changes. Conditions (all must be true): Any new PR or change to an existing PR. Automation Actions: Apply a color coded label that provides an estimated number of minutes someone will need to review the PR. Provide Estimated Time to Review # -*- mode: yaml -*- manifest : version : 1.0 automations : estimated_time_to_review : if : - true run : - action : add-label@v1 args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} calc : etr : {{ branch | estimatedReviewTime }} Download this example as a CM file.","title":"Provide Estimated Time to Review"},{"location":"automations/provide-estimated-time-to-review/#provide-estimated-time-to-review","text":"Label all PRs with an estimated number of minutes it would take someone to review. gitStream will automatically update this label whenever a PR changes. Conditions (all must be true): Any new PR or change to an existing PR. Automation Actions: Apply a color coded label that provides an estimated number of minutes someone will need to review the PR. Provide Estimated Time to Review # -*- mode: yaml -*- manifest : version : 1.0 automations : estimated_time_to_review : if : - true run : - action : add-label@v1 args : label : \" {{ calc.etr }} min review\" color : {{ 'E94637' if ( calc.etr >= 20 ) else ( 'FBBD10' if ( calc.etr >= 5 ) else '36A853' ) }} calc : etr : {{ branch | estimatedReviewTime }} Download this example as a CM file.","title":"Provide Estimated Time to Review"},{"location":"automations/request-screenshot/","text":"Request Screenshot If the PR lacks an image file, or link to an image in the description, apply a no-screenshot label and post a comment to request a screenshot. If the PR author updates the description, gitStream will remove the label. Conditions (all must be true): The PR description lacks an image or link to an image. Automation Actions: Apply a no-screenshot label. Post a comment that requests a screenshot. Update this action to provide specific context for your project. Request Screenshot # -*- mode: yaml -*- manifest : version : 1.0 automations : request_screenshot : # Triggered for PRs that lack an image file or link to an image in the PR description if : - {{ not ( has.screenshot_link or has.image_uploaded ) }} run : - action : add-label@v1 args : label : 'no-screenshot' color : '#FF000A' - action : add-comment@v1 args : comment : | Be a life saver \ud83d\udedf by adding a screenshot of the changes you made. has : screenshot_link : {{ pr.description | includes ( regex = r / !\\ [ . * \\ ] \\ ( . *( jpg | svg | png | gif | psd ) . * \\ )/) }} image_uploaded : {{ pr.description | includes ( regex = r /< img . * src . *( jpg | svg | png | gif | psd ) . *>/) }} Download this example as a CM file.","title":"Request Screenshot"},{"location":"automations/request-screenshot/#request-screenshot","text":"If the PR lacks an image file, or link to an image in the description, apply a no-screenshot label and post a comment to request a screenshot. If the PR author updates the description, gitStream will remove the label. Conditions (all must be true): The PR description lacks an image or link to an image. Automation Actions: Apply a no-screenshot label. Post a comment that requests a screenshot. Update this action to provide specific context for your project. Request Screenshot # -*- mode: yaml -*- manifest : version : 1.0 automations : request_screenshot : # Triggered for PRs that lack an image file or link to an image in the PR description if : - {{ not ( has.screenshot_link or has.image_uploaded ) }} run : - action : add-label@v1 args : label : 'no-screenshot' color : '#FF000A' - action : add-comment@v1 args : comment : | Be a life saver \ud83d\udedf by adding a screenshot of the changes you made. has : screenshot_link : {{ pr.description | includes ( regex = r / !\\ [ . * \\ ] \\ ( . *( jpg | svg | png | gif | psd ) . * \\ )/) }} image_uploaded : {{ pr.description | includes ( regex = r /< img . * src . *( jpg | svg | png | gif | psd ) . *>/) }} Download this example as a CM file.","title":"Request Screenshot"},{"location":"automations/review-sensitive-files/","text":"Review Sensitive Files Compare the changed files to a pre-defined list of files and directories in. If any files match, require a review from the team my-organization/security . Conditions (all must be true): Any files match the files or directories listed in the sensitive_files custom expression. Customize this list for your project. Automation Actions: Assign my-organization/security to review the PR. Customize this value to match your organization. Require 2 approvals. Post a comment that explains the automation. Review Sensitive Files # -*- mode: yaml -*- manifest : version : 1.0 automations : # Assign special teams to review sensitive files. # This requires the `sensitive` custom expression found at the bottom of this file. review_sensitive_files : # For all files listed in the sensitive custom expression. if : - {{ files | match ( list = sensitive_files ) | some }} run : # Add reviewers from the dev-leads team, and require two approvals # Modify `my-organization/security` to match your organization. - action : add-reviewers@v1 args : reviewers : [ my-organization/security ] - action : set-required-approvals@v1 args : approvals : 2 - action : add-comment@v1 args : comment : | This PR affects one or more sensitive files and requires review from the security team. # The `sensitive_file_review` automation requires this custom expression. # Modify this list to suit your security needs. sensitive_files : - src/app/auth/ - src/app/routing/ - src/app/resources/ Download this example as a CM file.","title":"Review Sensitive Files"},{"location":"automations/review-sensitive-files/#review-sensitive-files","text":"Compare the changed files to a pre-defined list of files and directories in. If any files match, require a review from the team my-organization/security . Conditions (all must be true): Any files match the files or directories listed in the sensitive_files custom expression. Customize this list for your project. Automation Actions: Assign my-organization/security to review the PR. Customize this value to match your organization. Require 2 approvals. Post a comment that explains the automation. Review Sensitive Files # -*- mode: yaml -*- manifest : version : 1.0 automations : # Assign special teams to review sensitive files. # This requires the `sensitive` custom expression found at the bottom of this file. review_sensitive_files : # For all files listed in the sensitive custom expression. if : - {{ files | match ( list = sensitive_files ) | some }} run : # Add reviewers from the dev-leads team, and require two approvals # Modify `my-organization/security` to match your organization. - action : add-reviewers@v1 args : reviewers : [ my-organization/security ] - action : set-required-approvals@v1 args : approvals : 2 - action : add-comment@v1 args : comment : | This PR affects one or more sensitive files and requires review from the security team. # The `sensitive_file_review` automation requires this custom expression. # Modify this list to suit your security needs. sensitive_files : - src/app/auth/ - src/app/routing/ - src/app/resources/ Download this example as a CM file.","title":"Review Sensitive Files"},{"location":"automations/welcome-newcomer/","text":"Welcome Newcomer Post a welcome message when someone makes their first PR to a repo, and provide context to help them know what's next. Conditions (all must be true): The PR author made their first contribution to the repo during the current day. Automation Actions: Add the my-organization/mentors team to review the PR. Customize this to match your organization. Apply a new-contributor label to the PR. Post a comment explaining the next steps. Customize this to match your project. Welcome Newcomer # -*- mode: yaml -*- manifest : version : 1.0 automations : # Help newcomers find mentors to guide them. welcome_newcomer : # If the PR author made their first contirbution on the current day if : - {{ repo.author_age < 1 and repo.age > 0 }} # 1. Add reviewers from the team `my_organization/mentors`. Replace this string to match your organization # 2. Apply a new-contributor label. # 3 Post a comment that explains the next steps. run : - action : add-reviewers@v1 args : reviewers : [ my_organization/mentors ] - action : add-label@v1 args : label : 'new-contributor' color : '#FBBD10' - action : add-comment@v1 args : comment : | Hello {{ pr.author }} \ud83d\udc4b Thanks for making your first PR, and welcome to our project! Our mentor team has automatically been assigned to review this PR and guide you through the process. Please reach out to that team if you have questions about the next steps. Download this example as a CM file.","title":"Welcome Newcomer"},{"location":"automations/welcome-newcomer/#welcome-newcomer","text":"Post a welcome message when someone makes their first PR to a repo, and provide context to help them know what's next. Conditions (all must be true): The PR author made their first contribution to the repo during the current day. Automation Actions: Add the my-organization/mentors team to review the PR. Customize this to match your organization. Apply a new-contributor label to the PR. Post a comment explaining the next steps. Customize this to match your project. Welcome Newcomer # -*- mode: yaml -*- manifest : version : 1.0 automations : # Help newcomers find mentors to guide them. welcome_newcomer : # If the PR author made their first contirbution on the current day if : - {{ repo.author_age < 1 and repo.age > 0 }} # 1. Add reviewers from the team `my_organization/mentors`. Replace this string to match your organization # 2. Apply a new-contributor label. # 3 Post a comment that explains the next steps. run : - action : add-reviewers@v1 args : reviewers : [ my_organization/mentors ] - action : add-label@v1 args : label : 'new-contributor' color : '#FBBD10' - action : add-comment@v1 args : comment : | Hello {{ pr.author }} \ud83d\udc4b Thanks for making your first PR, and welcome to our project! Our mentor team has automatically been assigned to review this PR and guide you through the process. Please reach out to that team if you have questions about the next steps. Download this example as a CM file.","title":"Welcome Newcomer"},{"location":"integrations/","text":"gitStream Integrations SonarCloud Security Dependabot Security Jira Project Management Swimm Documentation Jit (Coming Soon) .integrations { display:flex; flex-wrap: wrap; justify-content: center; } .integrations-card { display: flex; flex-direction: column; align-items: center; border: 2px solid white; border-radius: 10px; width: 200px; margin: 10px; } .integrations-card-title p{ font-size: 1.2em; margin-bottom: 1px; } .integrations-card-title a{ color: inherit; } .integrations-card-labels { font-size: 0.7em; color: #9aa4ad; /* this is a medium grey color */ margin-bottom: 5px; }","title":"Integrations"},{"location":"integrations/#gitstream-integrations","text":"SonarCloud Security Dependabot Security Jira Project Management Swimm Documentation Jit (Coming Soon) .integrations { display:flex; flex-wrap: wrap; justify-content: center; } .integrations-card { display: flex; flex-direction: column; align-items: center; border: 2px solid white; border-radius: 10px; width: 200px; margin: 10px; } .integrations-card-title p{ font-size: 1.2em; margin-bottom: 1px; } .integrations-card-title a{ color: inherit; } .integrations-card-labels { font-size: 0.7em; color: #9aa4ad; /* this is a medium grey color */ margin-bottom: 5px; }","title":"gitStream Integrations"},{"location":"integrations/dependabot/","text":"Integrate gitStream with Dependabot Approve and Merge Dependabot Changes Approve PRs from Dependabot Conditions (all must be true): The PR author is Dependabot. The branch name includes 'dependabot' Automation Actions: Approve the PR Apply an approved-dependabot label to the PR Merge the PR if all status checks pass. Approve Dependabot # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_dependabot : if : - {{ branch.name | includes ( term = \"dependabot\" ) }} - {{ branch.author | includes ( term = \"dependabot\" ) }} run : - action : approve@v1 - action : add-label@v1 args : label : \"approved-dependabot\" - action : merge@v1 args : wait_for_all_checks : true squash_on_merge : true Download this example as a CM file.","title":"Integrate gitStream with Dependabot"},{"location":"integrations/dependabot/#integrate-gitstream-with-dependabot","text":"","title":"Integrate gitStream with Dependabot"},{"location":"integrations/dependabot/#approve-and-merge-dependabot-changes","text":"Approve PRs from Dependabot Conditions (all must be true): The PR author is Dependabot. The branch name includes 'dependabot' Automation Actions: Approve the PR Apply an approved-dependabot label to the PR Merge the PR if all status checks pass. Approve Dependabot # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_dependabot : if : - {{ branch.name | includes ( term = \"dependabot\" ) }} - {{ branch.author | includes ( term = \"dependabot\" ) }} run : - action : approve@v1 - action : add-label@v1 args : label : \"approved-dependabot\" - action : merge@v1 args : wait_for_all_checks : true squash_on_merge : true Download this example as a CM file.","title":"Approve and Merge Dependabot Changes"},{"location":"integrations/jira/","text":"Integrate gitStream with Jira Label Missing Jira Info Label PRs that don't reference a Jira ticket in the title or description. This uses regex to detect Jira ticket formats in the title (e.g. ABC-1234), and URLs to Jira tickets in the description. Conditions (all must be true): The PR lacks a Jira ticket number in the title, or a link to a Jira ticket in the PR description. Automation Actions: Apply a missing-jira label. Label Missing Jira Info # -*- mode: yaml -*- manifest : version : 1.0 automations : label_missing_jira_info : # Triggered for PRs that don't have either a Jira ticket number in the title, # or a link to a Jira ticket in the PR description. if : - {{ not ( has.jira_ticket_in_title or has.jira_ticket_in_desc ) }} run : - action : add-label@v1 args : label : \"missing-jira\" color : 'F6443B' has : jira_ticket_in_title : {{ pr.title | includes ( regex = r / ^\\ [ ?\\ w { 3 , 4 }- \\ d { 1 , 6 } \\ ] ? ( \\ s | -| _ ) . { 1 ,} $ /) }} jira_ticket_in_desc : {{ pr.description | includes ( regex = r / atlassian.net \\ / browse \\ / \\ w { 1 ,}- \\ d { 3 , 4 }/) }} Download this example as a CM file.","title":"Integrate gitStream with Jira"},{"location":"integrations/jira/#integrate-gitstream-with-jira","text":"","title":"Integrate gitStream with Jira"},{"location":"integrations/jira/#label-missing-jira-info","text":"Label PRs that don't reference a Jira ticket in the title or description. This uses regex to detect Jira ticket formats in the title (e.g. ABC-1234), and URLs to Jira tickets in the description. Conditions (all must be true): The PR lacks a Jira ticket number in the title, or a link to a Jira ticket in the PR description. Automation Actions: Apply a missing-jira label. Label Missing Jira Info # -*- mode: yaml -*- manifest : version : 1.0 automations : label_missing_jira_info : # Triggered for PRs that don't have either a Jira ticket number in the title, # or a link to a Jira ticket in the PR description. if : - {{ not ( has.jira_ticket_in_title or has.jira_ticket_in_desc ) }} run : - action : add-label@v1 args : label : \"missing-jira\" color : 'F6443B' has : jira_ticket_in_title : {{ pr.title | includes ( regex = r / ^\\ [ ?\\ w { 3 , 4 }- \\ d { 1 , 6 } \\ ] ? ( \\ s | -| _ ) . { 1 ,} $ /) }} jira_ticket_in_desc : {{ pr.description | includes ( regex = r / atlassian.net \\ / browse \\ / \\ w { 1 ,}- \\ d { 3 , 4 }/) }} Download this example as a CM file.","title":"Label Missing Jira Info"},{"location":"integrations/sonar/","text":"Integrate gitStream with SonarCloud Included with gitStream Core Functionality This integration is part of gitStream core functionality, and requires no additional configuration. SonarCloud Examples: Approve Sonar Clean Code Label SonarCloud Quality Reports Review Sonar Duplications Review Sonar Security Alerts Approve Sonar Clean Code Approve PRs that pass SonarCloud's quality gate. Conditions (all must be true): SonarCloud reports an 'A' rating for vulnerabilities, bugs, security hotspots, and code smells. There is no duplicated code. Automation Actions: Apply a Sonar: Clean Code label to the PR. Approve the PR. Post a comment that explains why the PR was approved. Aprove Sonar Clean Code # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_sonar_clean_code : if : - {{ sonar.bugs.rating == 'A' }} - {{ sonar.code_smells.rating == 'A' }} - {{ sonar.vulnerabilities.rating == 'A' }} - {{ sonar.security_hotspots.rating == 'A' }} - {{ sonar.duplications == null or sonar.duplications == 0 }} run : - action : add-label@v1 args : label : '\u2705 Sonar: Clean Code' color : {{ colors.green }} - action : approve@v1 - action : add-comment@v1 args : comment : | This PR passes the SonarCloud quality gate check and as been automatically approved. sonar : {{ pr | extractSonarFindings }} colors : green : '0e8a16' Download this example as a CM file. Direct link to this example Label SonarCloud Quality Reports Label the number of bugs, vulnerabilities, security hotspots, and code smells reported by SonarCloud. Conditions (all must be true): There is at least one vulnerability, code smell, security hotspot, or bug reported by SonarCloud. Uses the extractSonarFindings filter function Automation Actions: Apply color-coded labels to indicate the number of vulnerabilities, code smells, security hotspots, and bugs. Label SonarCloud Quality Reports # -*- mode: yaml -*- manifest : version : 1.0 automations : {% for item in reports %} label_sonar_ {{ item.name }} : if : - {{ item.count > 0 }} run : - action : add-label@v1 args : label : ' {{ item.icon }} x {{ item.count }} {{ item.name }} ' color : {{ colors.red if ( item.rating == 'E' or item.rating == 'D' ) else ( colors.orange if ( item.rating == 'C' ) else colors.yellow ) }} {% endfor %} sonar : {{ pr | extractSonarFindings }} reports : - name : vulnerabilities count : {{ sonar.vulnerabilities.count }} icon : \ud83d\udd13 rating : {{ sonar.vulnerabilities.rating }} - name : code smells count : {{ sonar.code_smells.count }} icon : \u2623\ufe0f rating : {{ sonar.code_smells.rating }} - name : security hotspots count : {{ sonar.security_hotspots.count }} icon : \ud83d\udee1\ufe0f rating : {{ sonar.security_hotspots.rating }} - name : bugs count : {{ sonar.bugs.count }} icon : \ud83e\udeb2 rating : {{ sonar.bugs.rating }} colors : red : 'b60205' orange : 'd93f0b' yellow : 'fbca04' Download this example as a CM file. Direct link to this example Review Sonar Duplications Request changes when Sonar reports an excessive level of duplicated code. Conditions (all must be true): The PR contains more than 3% duplicated code. Automation Actions: Apply a label that indicates how much duplicated code Sonar detected. Request changes and post a comment explaining why. Review Sonar Duplications # -*- mode: yaml -*- manifest : version : 1.0 automations : review_sonar_duplications : if : - {{ sonar.duplications > 3 }} run : - action : add-label@v1 args : label : 'Sonar: {{ sonar.duplications }} % duplication' color : {{ colors.yellow }} - action : request-changes@v1 args : comment : | Sonar reports an excessive level of code duplication. Please consider refactoring your PR to reduce duplications. sonar : {{ pr | extractSonarFindings }} colors : yellow : 'fbca04' Download this example as a CM file. Direct link to this example Review Sonar Security Alerts Require additional reviews for Sonar security alerts. gitStream will remove this requirement if the alerts are resolved. Conditions (all must be true): The SonarCloud quality gate check fails to pass for code smells, vulnerabilities, or security hotspots. Automation Actions: Require a review from the my-organization/security-team team. Customize this to match your organization. Post a comment explaining why this PR requires additional review. Review Sonar Alerts # -*- mode: yaml -*- manifest : version : 1.0 automations : review_sonar_alerts : if : - {{ sonar.code_smells.rating != 'A' or sonar.vulnerabilities.rating != 'A' or sonar.security_hotspots.rating != 'A' }} run : - action : require-reviewers@v1 args : reviewers : [ my-organization/security-team ] - action : add-comment@v1 args : comment : | This PR requires additional review because it fails to meet SonarCloud clean code standards. sonar : {{ pr | extractSonarFindings }} Download this example as a CM file. Direct link to this example","title":"Integrate gitStream with SonarCloud"},{"location":"integrations/sonar/#integrate-gitstream-with-sonarcloud","text":"Included with gitStream Core Functionality This integration is part of gitStream core functionality, and requires no additional configuration. SonarCloud Examples: Approve Sonar Clean Code Label SonarCloud Quality Reports Review Sonar Duplications Review Sonar Security Alerts","title":"Integrate gitStream with SonarCloud"},{"location":"integrations/sonar/#approve-sonar-clean-code","text":"Approve PRs that pass SonarCloud's quality gate. Conditions (all must be true): SonarCloud reports an 'A' rating for vulnerabilities, bugs, security hotspots, and code smells. There is no duplicated code. Automation Actions: Apply a Sonar: Clean Code label to the PR. Approve the PR. Post a comment that explains why the PR was approved. Aprove Sonar Clean Code # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_sonar_clean_code : if : - {{ sonar.bugs.rating == 'A' }} - {{ sonar.code_smells.rating == 'A' }} - {{ sonar.vulnerabilities.rating == 'A' }} - {{ sonar.security_hotspots.rating == 'A' }} - {{ sonar.duplications == null or sonar.duplications == 0 }} run : - action : add-label@v1 args : label : '\u2705 Sonar: Clean Code' color : {{ colors.green }} - action : approve@v1 - action : add-comment@v1 args : comment : | This PR passes the SonarCloud quality gate check and as been automatically approved. sonar : {{ pr | extractSonarFindings }} colors : green : '0e8a16' Download this example as a CM file. Direct link to this example","title":"Approve Sonar Clean Code"},{"location":"integrations/sonar/#label-sonarcloud-quality-reports","text":"Label the number of bugs, vulnerabilities, security hotspots, and code smells reported by SonarCloud. Conditions (all must be true): There is at least one vulnerability, code smell, security hotspot, or bug reported by SonarCloud. Uses the extractSonarFindings filter function Automation Actions: Apply color-coded labels to indicate the number of vulnerabilities, code smells, security hotspots, and bugs. Label SonarCloud Quality Reports # -*- mode: yaml -*- manifest : version : 1.0 automations : {% for item in reports %} label_sonar_ {{ item.name }} : if : - {{ item.count > 0 }} run : - action : add-label@v1 args : label : ' {{ item.icon }} x {{ item.count }} {{ item.name }} ' color : {{ colors.red if ( item.rating == 'E' or item.rating == 'D' ) else ( colors.orange if ( item.rating == 'C' ) else colors.yellow ) }} {% endfor %} sonar : {{ pr | extractSonarFindings }} reports : - name : vulnerabilities count : {{ sonar.vulnerabilities.count }} icon : \ud83d\udd13 rating : {{ sonar.vulnerabilities.rating }} - name : code smells count : {{ sonar.code_smells.count }} icon : \u2623\ufe0f rating : {{ sonar.code_smells.rating }} - name : security hotspots count : {{ sonar.security_hotspots.count }} icon : \ud83d\udee1\ufe0f rating : {{ sonar.security_hotspots.rating }} - name : bugs count : {{ sonar.bugs.count }} icon : \ud83e\udeb2 rating : {{ sonar.bugs.rating }} colors : red : 'b60205' orange : 'd93f0b' yellow : 'fbca04' Download this example as a CM file. Direct link to this example","title":"Label SonarCloud Quality Reports"},{"location":"integrations/sonar/#review-sonar-duplications","text":"Request changes when Sonar reports an excessive level of duplicated code. Conditions (all must be true): The PR contains more than 3% duplicated code. Automation Actions: Apply a label that indicates how much duplicated code Sonar detected. Request changes and post a comment explaining why. Review Sonar Duplications # -*- mode: yaml -*- manifest : version : 1.0 automations : review_sonar_duplications : if : - {{ sonar.duplications > 3 }} run : - action : add-label@v1 args : label : 'Sonar: {{ sonar.duplications }} % duplication' color : {{ colors.yellow }} - action : request-changes@v1 args : comment : | Sonar reports an excessive level of code duplication. Please consider refactoring your PR to reduce duplications. sonar : {{ pr | extractSonarFindings }} colors : yellow : 'fbca04' Download this example as a CM file. Direct link to this example","title":"Review Sonar Duplications"},{"location":"integrations/sonar/#review-sonar-security-alerts","text":"Require additional reviews for Sonar security alerts. gitStream will remove this requirement if the alerts are resolved. Conditions (all must be true): The SonarCloud quality gate check fails to pass for code smells, vulnerabilities, or security hotspots. Automation Actions: Require a review from the my-organization/security-team team. Customize this to match your organization. Post a comment explaining why this PR requires additional review. Review Sonar Alerts # -*- mode: yaml -*- manifest : version : 1.0 automations : review_sonar_alerts : if : - {{ sonar.code_smells.rating != 'A' or sonar.vulnerabilities.rating != 'A' or sonar.security_hotspots.rating != 'A' }} run : - action : require-reviewers@v1 args : reviewers : [ my-organization/security-team ] - action : add-comment@v1 args : comment : | This PR requires additional review because it fails to meet SonarCloud clean code standards. sonar : {{ pr | extractSonarFindings }} Download this example as a CM file. Direct link to this example","title":"Review Sonar Security Alerts"},{"location":"integrations/swimm/","text":"Integrate gitStream with Swimm Approve Swimm Changes Approve changes that only affect Swimm documentation. Conditions (all must be true): The PR only affects files that end in a .swm extension. Automation Actions: Add a swimm-docs-only label Approve the PR Post a comment that explains that this is a Swimm docs change only. Approve Swimm Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_swimm_changes : # Triggered for any changes to Swimm documentation if : - {{ files | match ( regex = r / \\ .swm \\ //) | every }} # Apply a swimm-docs-only label, approve the PR and explain why in a comment. run : - action : add-label@v1 args : label : 'swimm-docs-only' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR is considered a safe change as it only affects Swimm Docs. It has been automatically approved. Download this example as a CM file. Special thanks to Omerr for providing this example.","title":"Integrate gitStream with Swimm"},{"location":"integrations/swimm/#integrate-gitstream-with-swimm","text":"","title":"Integrate gitStream with Swimm"},{"location":"integrations/swimm/#approve-swimm-changes","text":"Approve changes that only affect Swimm documentation. Conditions (all must be true): The PR only affects files that end in a .swm extension. Automation Actions: Add a swimm-docs-only label Approve the PR Post a comment that explains that this is a Swimm docs change only. Approve Swimm Changes # -*- mode: yaml -*- manifest : version : 1.0 automations : approve_swimm_changes : # Triggered for any changes to Swimm documentation if : - {{ files | match ( regex = r / \\ .swm \\ //) | every }} # Apply a swimm-docs-only label, approve the PR and explain why in a comment. run : - action : add-label@v1 args : label : 'swimm-docs-only' - action : approve@v1 - action : add-comment@v1 args : comment : | This PR is considered a safe change as it only affects Swimm Docs. It has been automatically approved. Download this example as a CM file. Special thanks to Omerr for providing this example.","title":"Approve Swimm Changes"}]}